<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hannie&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="hannie's blog">
<meta property="og:url" content="http://softwaretest.cn/page/3/index.html">
<meta property="og:site_name" content="hannie's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hannie's blog">
  
    <link rel="alternate" href="/atom.xml" title="hannie&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">hannie&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://softwaretest.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux-002" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/07/Linux-002/" class="article-date">
  <time datetime="2017-06-07T00:05:40.000Z" itemprop="datePublished">2017-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/07/Linux-002/">Linux-常用命令（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="8-查系统和用户信息"><a href="#8-查系统和用户信息" class="headerlink" title="8. 查系统和用户信息"></a>8. 查系统和用户信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uname -a  #会显示当前操作系统的所有信息。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hostname  #会显示主机的名称</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whoami    #会显示当前操作的用户</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">who       #会显示在线登陆的用户</div></pre></td></tr></table></figure>
<h2 id="9-清除屏幕-clear"><a href="#9-清除屏幕-clear" class="headerlink" title="9. 清除屏幕-clear"></a>9. 清除屏幕-clear</h2><p>若屏幕上的内容太多，可以使用clear清除屏幕<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clear     #清除屏幕</div></pre></td></tr></table></figure></p>
<h2 id="10-与文件目录相关的命令（一）"><a href="#10-与文件目录相关的命令（一）" class="headerlink" title="10. 与文件目录相关的命令（一）"></a>10. 与文件目录相关的命令（一）</h2><p>命令1：pwd（功能：显示当前目录的路径）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pwd    #显示当前目录的绝对路径</div></pre></td></tr></table></figure></p>
<p>命令2：cd（功能：切换到指定的目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd  /usr/bin   #从当前目录切换到/usr/bin子目录下</div><div class="line">cd ..          #从当前目录切换到上一层目录</div></pre></td></tr></table></figure></p>
<p>命令3：ls（功能：显示指定目录中的文件和子目录信息）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ls                        #显示当前目录下的文件和子目录信息</div><div class="line">ls -l                     #显示当前目录下的文件和子目录详细信息</div><div class="line">ls -l /home/eric/dhyblog  #显示指定的目录/home/eric/dhyblog下的所有文件和子目录的详细信息。</div></pre></td></tr></table></figure></p>
<p>命令4：cat（功能：显示文本文件内容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat 1.txt                #显示1.txt文本中的内容</div><div class="line">cat -n 1.txt             #显示1.txt文本中的内容，并且在每一行前显示行号。</div><div class="line">cat -n /home/eric/1.txt  #显示指定目录/home/eric下的1.txt文本中的内容，并且在每一行前显示行号。</div><div class="line">cat /etc/shells          #显示当前主机中的所有shell类型。</div></pre></td></tr></table></figure></p>
<p>命令5：more（功能：分屏显示文本总的内容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">more 1.txt  #若1.txt中的内容特别多，可以分屏显示。</div></pre></td></tr></table></figure></p>
<p>命令6：mkdir（功能：创建新的子目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir myfile             #在当前目录下创建了新的子目录myfile。</div><div class="line">mkdir /home/eric/myfile  #在指定的目录/home/eric下创建新的子目录myfile。</div></pre></td></tr></table></figure></p>
<p>命令7：rmdir（功能：删除空目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rmdir myfile             #若目录myfile为空则删除该目录。</div><div class="line">rmdir /home/eric/myfile  #删除指定目录/home/eric下的空目录myfile</div><div class="line">rmdir -p myfile          #当子目录myfile被删除后，当前的目录若也为空则一起删除。</div></pre></td></tr></table></figure></p>
<p>命令8：cp（功能：复制一个文件到另一个文件中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp 源文件 目标文件       #将源文件中的文件复制到目标文件中</div><div class="line">cp -r 源文件 目标文件    #将源文件中的文件复制到目标文件中，若源文件中有目录，则将目录下的文件也一起复制到目标文件中。</div></pre></td></tr></table></figure></p>
<p>命令9：mv（功能：移动一个文件到另一个文件中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv 源文件  目标文件      #将源文件中的文件移动到目标文件中</div><div class="line">mv -i 源文件 目标文件    #将源文件中的文件移动到目标文件中，若目标文件中已有同名文件则询问是否覆盖。</div></pre></td></tr></table></figure></p>
<p>命令10：rm（功能：删除文件及目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rm myfile    #删除myfile文件</div><div class="line">rm -i myfile #删除myfile中的文件时逐一询问是否删除</div><div class="line">rm -r myfile #删除myfile目录，目录下的文件也逐一删除</div><div class="line">rm -f myfile #若myfile文件为只读文件，也进行删除。</div></pre></td></tr></table></figure></p>
<p>（待续…………）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/07/Linux-002/" data-id="cjl997euq000n1tjy1qcj6kq3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/Linux-001/" class="article-date">
  <time datetime="2017-06-06T13:25:53.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/Linux-001/">Linux-常用命令（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-打开终端"><a href="#1-打开终端" class="headerlink" title="1. 打开终端"></a>1. 打开终端</h2><p>法一：键盘输入Ctrl+Alt+T<br>法二：Alt+F2   之后输入gnome_terminal</p>
<h2 id="2-进入root（超级用户）"><a href="#2-进入root（超级用户）" class="headerlink" title="2. 进入root（超级用户）"></a>2. 进入root（超级用户）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">——&gt; sudo su</div><div class="line">[sudo]password for eric:    #须在此处输入密码，但输入的密码不会显示在屏幕上</div><div class="line">root@eric-pc:               #当显示root@后就代表已经进入了root</div></pre></td></tr></table></figure>
<h2 id="3-退出root"><a href="#3-退出root" class="headerlink" title="3. 退出root"></a>3. 退出root</h2><p>直接输入exit就可以退出root。</p>
<h2 id="4-与-的区别："><a href="#4-与-的区别：" class="headerlink" title="4. $与#的区别："></a>4. $与#的区别：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ 表示当前用户为普通用户</div><div class="line"># 表示当前用户为超级用户</div></pre></td></tr></table></figure>
<p>（ps：在python和shell中，以#开头的文本作为注释行）</p>
<h2 id="5-重启电脑"><a href="#5-重启电脑" class="headerlink" title="5.重启电脑"></a>5.重启电脑</h2><p>法一：进入root后，键入reboot            #表示立即重启<br>法二：进入root后，键入shutdown -r now   #表示立即重启<br>法三：进入root后，键入shutdown -r 5     #表示5分钟后自动重启<br>法四：进入root后，键入shutdown -r 20:30 #表示在20:30时自动重启<br>（若想取消设置的重启，则可键入shutdown -e）</p>
<h2 id="6-关机"><a href="#6-关机" class="headerlink" title="6. 关机"></a>6. 关机</h2><p>法一：进入root后，键入halt            #表示立即关机<br>法二：进入root后，键人poweroff        #表示立即关机<br>法二：进入root后，键入shutdown -h now   #表示立即关机<br>法三：进入root后，键入shutdown -h 5     #表示5分钟后自动关机<br>法四：进入root后，键入shutdown -h 20:30 #表示在20:30时自动关机<br>（若想取消设置的关机，则可键入shutdown -e）</p>
<h2 id="7-需要帮助"><a href="#7-需要帮助" class="headerlink" title="7. 需要帮助"></a>7. 需要帮助</h2><p>在需要帮助时记得用man和help<br>法一：键入：man 命令名，就可以显示该命令的帮助文档。<br>      想退出帮助文档时键入 q 即可。<br>法二：键入：命令名 –help，就可以显示该命令的帮助。<br>      例如：cat –help<br>法三：help 命令名，可用于查找shell内部命令的帮助文档。<br>      键入：bash    #进入了bash（bash是linux系统默认使用的shell类型，常用的还有zsh csh ksh ash）<br>      键入：help cd #查找cd命令的帮助文档<br>      键入：exit    #退出bash</p>
<p>（待续…………）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/06/Linux-001/" data-id="cjl997eun000k1tjyxbx1k178" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Echo-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/Echo-001/" class="article-date">
  <time datetime="2017-06-06T12:09:25.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/Echo-001/">终端打印-echo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-终端打印-echo"><a href="#一-终端打印-echo" class="headerlink" title="一. 终端打印-echo"></a>一. 终端打印-echo</h2><p>特点：每次调用之后会自动添加一个换行符<br>1、可以使用 -n 来忽略结尾的换行符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo -n &quot;hello&quot;</div><div class="line">hello</div></pre></td></tr></table></figure></p>
<p>2、可以使用 -e 来使用转义序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;1\t2\t3\t&quot;</div><div class="line">1	2	3</div></pre></td></tr></table></figure></p>
<h2 id="二-终端打印-printf"><a href="#二-终端打印-printf" class="headerlink" title="二. 终端打印-printf"></a>二. 终端打印-printf</h2><p>特点：每次调用时不会自动添加换行符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ printf &quot;hello&quot;</div><div class="line">hello</div></pre></td></tr></table></figure></p>
<h2 id="三-终端打印的小应用"><a href="#三-终端打印的小应用" class="headerlink" title="三. 终端打印的小应用"></a>三. 终端打印的小应用</h2><p>1、要打印彩色背景的文本：黑=40 红=41 绿=42 黄=43 蓝=44 重置=0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;\e[1;42m green background \e[0m&quot;</div></pre></td></tr></table></figure></p>
<p>2、要打印彩色的文本：黑=30 红=31 绿=32 黄=33 蓝=34 重置=0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;\e[1;31m this is red text \e[0m&quot;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/06/Echo-001/" data-id="cjl997eul000f1tjyxrxrql60" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vim-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/vim-001/" class="article-date">
  <time datetime="2017-06-06T11:37:44.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/vim-001/">vim的三种模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-普通模式："><a href="#一-普通模式：" class="headerlink" title="一. 普通模式："></a>一. 普通模式：</h2><p>1、通过以下命令进入的则是普通模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim 1.txt   #1.txt为要编辑的文档。若该文档存在时则直接打开编辑，若该文档不存在则新建1.txt文档后打开编辑。</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim -R 1.txt  #以只读模式打开文件1.txt</div></pre></td></tr></table></figure>
<p>2、当在“输入模式”或者“命令模式”时，按键盘左上角的“Esc”可回到普通模式。<br>3、在普通模式下，通常会进行复制，粘贴，移动，删除等操作。</p>
<h2 id="二-插入模式："><a href="#二-插入模式：" class="headerlink" title="二. 插入模式："></a>二. 插入模式：</h2><p>1、进入普通模式后，再输入i或a或o或I或A或O，均可进入插入模式。<br>2、若在命令模式中，要想进入插入模式，需要先按下按键“Esc”回到普通模式后，再进入插入模式。<br>3、在插入模式下，通常进行输入字符操作。</p>
<h2 id="三-命令模式："><a href="#三-命令模式：" class="headerlink" title="三. 命令模式："></a>三. 命令模式：</h2><p>1、若目前在普通模式下，想要进入命令模式，需要键入：（冒号）可进入命令模式。<br>2、若目前在插入模式下，想要进入命令模式，需要按下按键“ESC”回到普通模式后，再进入命令模式。<br>3、在命令模式下，通常进行保存该文档，或退出vim，或对vim编辑器做一些设置，或运行lunux命令等操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/06/vim-001/" data-id="cjl997evn001p1tjy04482cxk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/">VIM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shell-003" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/04/shell-003/" class="article-date">
  <time datetime="2017-06-04T12:52:45.000Z" itemprop="datePublished">2017-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/shell-003/">shell是什么？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、shell是什么？"><a href="#一、shell是什么？" class="headerlink" title="一、shell是什么？"></a>一、shell是什么？</h2><p>shell 的本意是“壳”的意思。形象的说明了shell是围绕在Linux内核之外的一个“壳”程序。shell是用户和操作系统内核之间通讯的桥梁。<br>shell是一种<strong>命令解释程序</strong>：它解释用户输入的命令，然后提交为内核处理，最后把结果返回给用户。<br>shell是一种<strong>解释型的程序设计语言</strong>：它定义了各种选项和变量，有函数，表达式，循环等，可以利用shell编写shell 脚本。</p>
<h2 id="二、Linux下有很多shell"><a href="#二、Linux下有很多shell" class="headerlink" title="二、Linux下有很多shell"></a>二、Linux下有很多shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cat /etc/shells  #查看系统下的所有shell</div><div class="line"></div><div class="line">/bin/bash</div><div class="line">/bin/csh</div><div class="line">/bin/ksh</div><div class="line">/bin/sh</div><div class="line">/bin/tcsh</div><div class="line">/bin/zsh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo $SHELL     #查看当前用户默认使用的shell</div><div class="line"></div><div class="line">/bin/zsh       #我的系统默认使用的是zsh</div></pre></td></tr></table></figure>
<h2 id="三、shell命令的语法"><a href="#三、shell命令的语法" class="headerlink" title="三、shell命令的语法"></a>三、shell命令的语法</h2><p>比如 cd pwd exit echo等命令是bash的内置命令，当用户登录系统后，shell以及内置的命令就被系统载入到内存中，并且一直运行，直到用户退出程序为止。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/04/shell-003/" data-id="cjl997evk001m1tjy24xbqaa8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-005" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/05/APP-Test-005/" class="article-date">
  <time datetime="2017-03-05T09:23:55.000Z" itemprop="datePublished">2017-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/05/APP-Test-005/">APP测试总结（五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="测试文档编写与缺陷管理"><a href="#测试文档编写与缺陷管理" class="headerlink" title="测试文档编写与缺陷管理"></a>测试文档编写与缺陷管理</h2><p>测试文档包括：测试计划文档，测试设计规格文档，测试用例，软件缺陷报告，状态报告。</p>
<p>测试用例对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。测试用例一般包括验证测试用例和证伪测试用例；验证测试用例用于验证代码是否按照预期执行，得到预期结果；证伪测试用例验证代码是否对异常和错误条件进行了适当处理。</p>
<p>缺陷报告包括：问题/错误的简单描述，重现的环境配置要求，保证多次精确重复的特定输入，期望结果与实际结果的对比，优先级与严重性，对客户的影响等。</p>
<h2 id="常用的测试工具"><a href="#常用的测试工具" class="headerlink" title="常用的测试工具"></a>常用的测试工具</h2><h3 id="功能测试UFT"><a href="#功能测试UFT" class="headerlink" title="功能测试UFT"></a>功能测试UFT</h3><h4 id="UFT自动化测试的原理"><a href="#UFT自动化测试的原理" class="headerlink" title="UFT自动化测试的原理"></a>UFT自动化测试的原理</h4><ul>
<li>封装真实被测对象并转化为UFT对象到对象库。</li>
<li>对比对象库里的对象鉴别属性和运行时的真实被测对象的鉴别属性。</li>
<li>对比结果一致，则说明对象成功匹配并可以继续对该真实被测对象进行后续操作；如果不一致则报错，提示对象无法识别。</li>
</ul>
<h3 id="封装对象模型"><a href="#封装对象模型" class="headerlink" title="封装对象模型"></a>封装对象模型</h3><p>在UFT里的封装对象共分两个概念，Test Objects（测试对象，TO）和Runtime Objects（运行时对象，RO）。TO就是被被添加到对象库中的对象，RO就是被测试软件在运行实际所运行的对象。他们都是UFT封装的对象，TO是为了识别RO而存在的。</p>
<p>UFT识别对象通常先在对象库中添加测试对象，然后在被测软件运行的时候，根据脚本中调用的对象名称，在对象库中找到相应的测试对象，并根据这些对象的特征属性，在被测试软件中搜索相匹配的正在运行的对象，最后就可以对这些实际运行的测试对象进行操作。</p>
<p>GetTOProperty()<br>    基本含义：获取对象库中某个对象的某个属性的值。<br>    公式：ReturnValue = 对象.GetTOProperty(“封装属性名”)</p>
<pre><code>SetTOProperty()
基本含义：设置对象库中某个对象的某个属性的值。
公式：对象.SetTOProperty &quot;封装属性名&quot; &quot;封装属性值&quot;
注：使用代码形式的修改对象属性属于临时性的，只在脚本运行时有效，一旦脚本运行结束，对象库里的属性值就会还原。

GetROProperty()
基本含义：获取实际运行时的某个对象的某个属性的值。
公式：ReturnValue = 对象.GetROProperty(&quot;封装属性名&quot;)
注：使用GetROProperty这个方法来动态获取实际运行时的一些确认信息，然后和所预期的测试数据做对比。如注册功能，在提交一些注册信息以后，一般都要到接下来的确认页面去验证一些信息，这就可以使用GetROProperty来动态获取实际运行时的一些确认信息。
</code></pre><h4 id="对象无法识别的解决办法"><a href="#对象无法识别的解决办法" class="headerlink" title="对象无法识别的解决办法"></a>对象无法识别的解决办法</h4><pre><code>设置虚拟对象。不推荐，虚拟对象非常脆弱，难以维护；即使对象没有发生变化，但只要对象在界面是那个的方位发生变化，虚拟对象就会识别失败。
使用相对坐标配合WSH去定位对象。
使用DOM组建接口应用技术。只适用于Web项目。
使用UFT自定义扩展SDK Customer来进行二次开发使UFT能够识别对象。难度大。
开发提供专属插件。
把无法识别的对象的一些方法封装到一个dll中并使用UFT调用。
</code></pre><h4 id="数据驱动与场景恢复"><a href="#数据驱动与场景恢复" class="headerlink" title="数据驱动与场景恢复"></a>数据驱动与场景恢复</h4><pre><code>数据驱动Data Table的应用：实现测试数据和脚本业务的分离。
场景恢复：场景恢复可以应对多种类型的错误并进行恢复操作。
</code></pre><h3 id="性能测试LoadRunner"><a href="#性能测试LoadRunner" class="headerlink" title="性能测试LoadRunner"></a>性能测试LoadRunner</h3><ul>
<li>LoadRunner是一种适用于各种体系架构的自动负载测试工具，它能预测系统行为并优化系统性能。LoadRunner的测试对象是整个企业的系统，它通过模拟实际用户的操作行为和实时性能监测，来帮助测试人员更快地查找和发现问题。<br>*</li>
<li>轻松创建虚拟用户。Virtual User Generator能够生成虚拟用于，以虚拟用户的方式模拟真实用户的业务操作行为。它先记录下业务流程，然后将其转化为测试脚本，并进行参数化操作（Data Wizard直接连接数据服务器获取数据）。利用虚拟用户可以在不同操作系统上同时产生成千上万用户访问，能极大的减少负载测试所需要的硬件和人力资源。</li>
<li>创建真实负载。建立虚拟用户后，需要设定负载方案、业务流程组合和虚拟用户数量。用Controller能够很快地组织多用户测试方案。</li>
<li>定位性能问题。LoadRunner内含一个实时检测器，在负载测试过程的任何时候都能观察到应用系统的运行性能。</li>
<li>分析结果。一旦测试完毕，LoadRunner收集汇总所有的测试数据，并提供高级的分析和报告工具，一遍迅速找到性能问题并做出相应的调整。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/03/05/APP-Test-005/" data-id="cjl997eu500041tjy0leh9jul" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-004" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/25/APP-Test-004/" class="article-date">
  <time datetime="2017-02-25T09:23:55.000Z" itemprop="datePublished">2017-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/25/APP-Test-004/">APP测试总结（四）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h2 id="自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。"><a href="#自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。" class="headerlink" title="自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。"></a>自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。</h2><ul>
<li><p>冒烟测试:就是在一个新版本出来的时候，将软件的全部功能过一遍，看有没有什么大问题。如果功能可以正常运行，不会影响测试进行，那么这个版本就可以真正开始测试了。如果功能有重大问题或影响测试进行，那么这个版本就是不合格的，不用进行进一步的测试。比如，拿到QQ的app新版本，登陆都登陆不上，那么这个版本肯定无法继续测下去。或者，游戏中新的模块出现，但是新的模块总是崩溃、卡死，测试进行不下去，那么冒烟的结果就是不合格的。</p>
</li>
<li><p>回归测试:就是以前版本中发现的bug在新的版本中验证是否存在且是否引发新的bug。</p>
</li>
</ul>
<h2 id="自动化测试的优势"><a href="#自动化测试的优势" class="headerlink" title="自动化测试的优势"></a>自动化测试的优势</h2><ul>
<li>回归测试更方便、可靠。由于回归测试的业务流程操作和测试用例是预先设计好的，预期结果也是完全在项目人员掌握之中的，将回归测试交给计算机自动运行，可以极大提高测试效率，缩短回归测试时间。</li>
<li>可运行更多更繁琐的测试，且快速高效。</li>
<li>可执行一些对于手工测试来说相当困难或根本做不到的测试。比如，对大量用户的并发测试等。</li>
<li>具有一致性和可重复性的特点。</li>
<li>自动化测试脚本完全具有复用性。由于自动化测试通常以脚本的方式实现，这样在不同的版本之间，就可能只需要做少量的维护甚至不做任何修改，实现在不同的测试版本中使用相同的测试脚本执行相同的测试用例。</li>
</ul>
<h2 id="自动化测试的劣势"><a href="#自动化测试的劣势" class="headerlink" title="自动化测试的劣势"></a>自动化测试的劣势</h2><ul>
<li>永远不可能完全取代手工测试。自动化测试无法做到手工测试的覆盖率，不是每个测试用例都适合转换成自动化测试用例的。</li>
<li>无法保证测试的正确性。测试脚本本身也可能存在缺陷。</li>
<li>手工测试能发现的缺陷远比自动化测试多。自动化测试几乎是无法发现新缺陷。</li>
<li>自动化测试工具是死的，它本身没有任何想象力。</li>
<li>自动化测试对测试工程师来说必须有一定的开发技术背景。</li>
</ul>
<h2 id="引入自动化测试的时机"><a href="#引入自动化测试的时机" class="headerlink" title="引入自动化测试的时机"></a>引入自动化测试的时机</h2><p>项目周期长，系统版本不断。主要在于回归测试。<br>需求变更不频繁。<br>系统中的测试对象基本可以正常识别，不存在大批量第三方控件。<br>需要反复测试，如可靠性测试需要进行上千次的系统测试。</p>
<h2 id="何时避免展开自动化测试"><a href="#何时避免展开自动化测试" class="headerlink" title="何时避免展开自动化测试"></a>何时避免展开自动化测试</h2><p>项目周期短，需求变更频繁。项目周期短的情况下引入自动化测试，不但收不回成本，而且会延长产品的发布时间。需求频繁改变会使老功能的业务逻辑被修改，从而导致相应的测试脚本也需相应修改。<br>软件版本还没稳定。<br>多数对象无法识别以及脚本维护频繁与艰难。</p>
<h2 id="自动化测试用例设计"><a href="#自动化测试用例设计" class="headerlink" title="自动化测试用例设计"></a>自动化测试用例设计</h2><p>在项目的测试过程中，测试工程师都会首先分析测试需求，产出测试计划后，编写和设计测试用例，设计开发测试脚本。</p>
<ul>
<li>自动化测试用例的范围往往是核心业务流程或者重复执行率较高的。并不需要覆盖所有的手工测试用例。</li>
<li>自动化测试用例的选择一般以“正向”为主。正常情况即为“正向”，异常情况即为“反向”。功能自动化测试主要还是用于回归测试，回归测试的目的就是保证新增功能后老功能是否能够正常运作。</li>
<li>手工测试用例可以不用回归原点，而自动化用例往往是必须的。所谓回归原点就是执行的测试用例最终需要恢复其在执行前的初始状态。比如添加用户功能，由于用户名是唯一的，第一次执行时没有问题，第二次执行时程序就会出现用户名重复而报错；这种情况下，就需要在自动化测试用例最后增加删除该用户的步骤。</li>
<li>自动化测试用例与手工测试用例不同，不需要每个步骤都写预期结果。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/02/25/APP-Test-004/" data-id="cjl997eu900051tjyttg6yc4n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-003" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/21/APP-Test-003/" class="article-date">
  <time datetime="2017-02-21T09:23:55.000Z" itemprop="datePublished">2017-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/APP-Test-003/">APP测试总结（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="软件测试类型"><a href="#软件测试类型" class="headerlink" title="软件测试类型"></a>软件测试类型</h2><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试并不是对整个程序进行测试，而是对构成程序的较小模块进行测试。单元测试减小了调试的难度（一旦某个错误被发现出来，我们就知道它在哪个具体的模块中）；单元测试提供了同时测试多个模块的可能，将并行工程引入软件测试中。</p>
<p>在为模块单元测试设计测试用例时，需要使用两种类型的信息：模块的规格说明和模块的源代码。规格说明一般都规定了模块的输入和输出参数以及模块的功能。单元测试总体上是面向白盒测试的，因此，单元测试的测试用例的设计过程如下：使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>自顶向下集成和自底向上集成</p>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>功能测试的目的是为了暴露程序的错误以及与规格说明不一致之处，而不是为了证明程序符合其外部规格说明。</p>
<p>功能测试是一种黑盒测试，功能测试常用步骤有：根据需求来细分功能点，根据功能点派生测试需求，根据测试需求设计功能测试用例。</p>
<h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>系统测试的目的是为了证明程序不能实现其目标，系统测试的测试用例设计有以下14种类型：</p>
<ul>
<li>能力测试：是判断目标文档提及的每一项能力（或功能）是否都确实已经实现。</li>
<li>容量测试：使程序经受大容量数据的检验。容量测试的目的是为了证明程序不能处理目标文档中规定的数据容量。</li>
<li>强度测试：使程序承受高负载或强度的检验。所谓高强度是指在很短的时间间隔内达到的数据或操作的数量峰值。</li>
<li>易用性测试：试图发现人为因素或易用性的问题。</li>
<li>安全性测试：设计测试用例来突破程序安全检查的过程。举例来说，我们可以设计测试用例来规避操作系统的内存保护机制，破坏数据库管理系统的数据安全机制。</li>
<li>性能测试：很多软件都有特定的性能或效率目标，这终特性描述为在特定负载和配置环境下程序的响应时间和吞吐率。</li>
<li>存储测试：</li>
<li>配置测试：</li>
<li>兼容性测试。</li>
<li>安装测试：有些类型的软件系统安装过程非常复杂，测试安装过程是系统测试中的一个重要部分。对于包含在软件包中的自动安装系统而言，这尤其重要。安装程序如果出现故障，会影响用户对软件的成功体验。</li>
<li>可靠性测试：所有类型的测试都是为了提高软件的可靠性，但是如果软件的目标中包含了对可靠性的特别描述，就必须设计专门的可靠性测试。</li>
<li>可恢复性测试：诸如操作系统、数据库管理系统和远程处理系统等软件通常都有可恢复性目标，说明系统如何从程序错误、硬件失效和数据错误中恢复过来。系统测试的一个目标是证明这些恢复机制不能够正确发挥作用。我们可以故意将程序错误置入某个系统中，判断系统是否可以从中恢复。</li>
<li>适用性测试</li>
<li>文档测试：检查用户文档的正确性。用户文档应成为审查的对象，检查其正确性和清晰性。在文档中描述的任何范例应编成测试用例，并提交给程序。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/02/21/APP-Test-003/" data-id="cjl997eu300031tjybee6lumn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-002" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/19/APP-Test-002/" class="article-date">
  <time datetime="2017-02-19T09:23:55.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/APP-Test-002/">APP测试总结（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><p>测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果。测试用例是执行的最小实体。简单地说，测试用例就是设计一个场景，使软件程序在这种场景下，必须能够正常运行并且达到程序所设计的执行结果。</p>
<p>##1.1 黑盒测试与白盒测试</p>
<p>黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。白盒测试：已知产品的内部工作过程，可以进行测试证明每种内部操作是否符合设计规格要求，所有内部成分是否经过检查。</p>
<p>合理的测试策略是将这两种测试要素组合起来。我们可以通过使用特定的面向黑盒测试的测试用例设计方法，而后使用白盒测试方法对程序的逻辑结构进行检查以补充这些测试用例，借此来设计出一个相当严格的测试。</p>
<p>白盒测试方法有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖。黑盒测试方法有等价类划分、边界值分析、因果图分析、错误测试、状态图、场景法等。</p>
<h2 id="1-2-白盒测试用例设计"><a href="#1-2-白盒测试用例设计" class="headerlink" title="1.2 白盒测试用例设计"></a>1.2 白盒测试用例设计</h2><p>白盒测试关注的是测试用例执行的程度或覆盖程序逻辑结构（源代码）的程度。完全的白盒测试是将程序中每条路径都执行到，然而对一个带有循环的程序来说，完全的路径测试并不切合实际。白盒测试的特点：依据软件设计说明书进行测试、对程序内部细节的严密检验、针对特定条件设计测试用例、对软件的逻辑路径进行覆盖测试。</p>
<p>语句覆盖是最起码的结构覆盖要求，语句覆盖要求设计足够多的测试用例，使得程序中每条语句至少被执行一次。可以很直观地从源代码得到测试用例，无须细分每条判定表达式。由于这种测试方法仅仅针对程序逻辑中显式存在的语句，但对于隐藏的条件和可能到达的隐式逻辑分支，是无法测试的。（遗漏隐藏的逻辑分支）</p>
<p>判定覆盖要求必须编写足够的测试用例，使得每一个判断都至少有一个为“真”和为“假”的输出结果。判定覆盖比语句覆盖要多几乎一倍的测试路径，当然也就具有比语句覆盖更强的测试能力。同样判定覆盖也具有和语句覆盖一样的简单性，无须细分每个判定就可以得到测试用例。往往大部分的判定语句是由多个逻辑条件组合而成（如，判定语句中包含AND、OR、CASE），若仅仅判断其整个最终结果，而忽略每个条件的取值情况，必然会遗漏部分测试路径。（遗漏组合判定中的某些条件取值）</p>
<p>条件覆盖要求设计足够多的测试用例，使得判定中的每个条件获得各种可能的结果，即每个条件至少有一次为真值，有一次为假值。要达到条件覆盖，需要足够多的测试用例，但条件覆盖并不能保证判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果。</p>
<p>判定/条件覆盖要求设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。判定/条件覆盖满足判定覆盖准则和条件覆盖准则，弥补了二者的不足。判定/条件覆盖准则的缺点是未考虑条件的组合情况。</p>
<p>多重条件覆盖要求设计足够多的测试用例，使得每个判定中条件结果的所有可能组合至少出现一次。多重条件覆盖准则满足判定覆盖、条件覆盖和判定/条件覆盖准则。更改的判定/条件覆盖要求设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身的所有可能结果也至少出现一次。并且每个条件都显示能单独影响判定结果。缺点是线性地增加了测试用例的数量。</p>
<p>路径覆盖要求设计足够的测试用例，覆盖程序中所有可能的路径。由于路径覆盖需要对所有可能的路径进行测试（包括循环、条件组合、分支选择等），那么需要设计大量、复杂的测试用例，使得工作量呈指数级增长。而在有些情况下，一些执行路径是不可能被执行的，这样不仅降低了测试效率，而且大量的测试结果的累积，也为排错带来麻烦。</p>
<h2 id="1-3-黑盒测试用例设计"><a href="#1-3-黑盒测试用例设计" class="headerlink" title="1.3 黑盒测试用例设计"></a>1.3 黑盒测试用例设计</h2><h3 id="1-3-1-等价类划分"><a href="#1-3-1-等价类划分" class="headerlink" title="1.3.1 等价类划分"></a>1.3.1 等价类划分</h3><p>等价类划分是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。等价类分为有效等价类和无效等价类，其中，有效等价类是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合；而无效等价类是指对于程序的规格说明来说是不合理的，没有意义的输入数据构成的集合。设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。划分等价类有以下原则：</p>
<ul>
<li>在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0～100；则小于0和大于100的为无效等价类，0~100之间的为有效等价类。</li>
<li>在输入条件规定了输入值的集合或者规定了”必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类。</li>
<li>在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类。</li>
<li>在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类。例：输入条件说明学历可为:专科、本科、硕士、博士四种之一，则分别取这四种这四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。</li>
<li>在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；</li>
<li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。</li>
<li>在确立了等价类后,可建立等价类表,列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：</li>
</ul>
<p>为每一个等价类规定一个唯一的编号；</p>
<ul>
<li>设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；</li>
<li>设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止。</li>
</ul>
<h3 id="1-3-2-边界值分析"><a href="#1-3-2-边界值分析" class="headerlink" title="1.3.2 边界值分析"></a>1.3.2 边界值分析</h3><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。</p>
<p>长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。</p>
<h3 id="1-3-3-因果图"><a href="#1-3-3-因果图" class="headerlink" title="1.3.3 因果图"></a>1.3.3 因果图</h3><p>因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p>
<p>等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。</p>
<h3 id="1-3-4-错误测试"><a href="#1-3-4-错误测试" class="headerlink" title="1.3.4 错误测试"></a>1.3.4 错误测试</h3><p>错误测试是基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。</p>
<p>如测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：</p>
<ul>
<li>输入的线性表为空表；</li>
<li>表中只含有一个元素；</li>
<li>输入表中所有元素已排好序；</li>
<li>输入表已按逆序排好；</li>
<li>输入表中部分或全部元素相同。</li>
</ul>
<h2 id="1-4-测试用例设计综合策略"><a href="#1-4-测试用例设计综合策略" class="headerlink" title="1.4 测试用例设计综合策略"></a>1.4 测试用例设计综合策略</h2><p>Myers提出了使用各种测试方法的综合策略：</p>
<ul>
<li>在任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强。</li>
<li>必要时用等价类划分方法补充一些测试用例。</li>
<li>用错误推测法再追加一些测试用例。</li>
<li>对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，应当再补充足够的测试用例。</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法。</li>
</ul>
<p>测试用例的设计步骤：1)构造根据设计规格得出的基本功能测试用例；2)边界值测试用例；3)状态转换测试用例；4)错误猜测测试用例；5)异常测试用例；6)性能测试用例；7)压力测试用例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/02/19/APP-Test-002/" data-id="cjl997etz00011tjy79gid6n9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/19/APP-Test-001/" class="article-date">
  <time datetime="2017-01-19T09:23:55.000Z" itemprop="datePublished">2017-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/19/APP-Test-001/">APP测试总结（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="APP测试流程"><a href="#APP测试流程" class="headerlink" title="APP测试流程"></a>APP测试流程</h1><h2 id="1-UI-测试"><a href="#1-UI-测试" class="headerlink" title="1. UI 测试"></a>1. UI 测试</h2><p>app主要核ui与实际设计的效果图是否一致；交互方面的问题建议，可以先与产品经理确认，确认通过后，才开始让开发实施更改或优化</p>
<h2 id="2-功能测试"><a href="#2-功能测试" class="headerlink" title="2. 功能测试"></a>2. 功能测试</h2><p>根据软件说明或用户需求验证App的各个功能实现，实际测试过程一般都是根据功能测试用例来执行。测试覆盖率基本上都是有测试用例主导，也就是说在功能测试部分，是检验测试用例是否有效以及完整的，也就导致另外一个问题，测试用例怎么写的问题，将另外一篇文章来单独阐述测试用例的编写方法。</p>
<h2 id="3-中断测试"><a href="#3-中断测试" class="headerlink" title="3. 中断测试"></a>3. 中断测试</h2><p>模拟用户真实使用app是会遇到的中断情况进行测试.如： 网络的断网， 切换网络， 断电，来电话/短信，听音乐，切换到其他app， 打开其他app 的通知等</p>
<h2 id="4-兼容以及适配测试"><a href="#4-兼容以及适配测试" class="headerlink" title="4. 兼容以及适配测试"></a>4. 兼容以及适配测试</h2><p>新旧版本的在功能，逻辑层面的兼容测试， 同一个app 在不同系统版本运行，以及不同机型之间的适配测试兼容测试：接口的兼容性测试能够保证大部分的功能完善；app在不同系统版本上保证运行适配性： 屏幕，系统版本等（系统位数一定要考虑）该部分通过第三方的云平台进行</p>
<h2 id="5-性能测试"><a href="#5-性能测试" class="headerlink" title="5. 性能测试"></a>5. 性能测试</h2><p>可测试的方面- 安装和启动时间- CPU的占用- 内存的占用- 流量的耗用- 电量的耗用- 后端,测试App中的各类操作是否满足用户响应时间要求，主要是测试点在网速方面，2g，3g，wifi， 4g一定要覆盖到- 后端 有网络并发</p>
<h2 id="6-稳定性测试，压力测试"><a href="#6-稳定性测试，压力测试" class="headerlink" title="6. 稳定性测试，压力测试"></a>6. 稳定性测试，压力测试</h2><ul>
<li>在各种边界压力情况下（如电池、存储、网速等），验证App是否能正确响应</li>
<li>反复/长期操作下，系统资源是否占用异常；Android 可是使用adb命令</li>
<li>压力测试主要集中在后端，前端的压力测试目前测的较少</li>
</ul>
<h2 id="7-安全测试"><a href="#7-安全测试" class="headerlink" title="7.安全测试"></a>7.安全测试</h2><p>App安全测试大概划分为以下几类：</p>
<ul>
<li>从数据的本地存储到数据的传输、处理以及远程访问等各个环节，基于相应的安全标准/行业标准评估App的安全特性；</li>
<li>借鉴在Web App和网络安全测试的一些成功经验在智能终端App测试中进行裁减或适配；</li>
<li>检测App的用户授权级别，数据泄漏，非法授权访问等；</li>
<li>对App的输入有效性校验、认证、授权、敏感数据存储、数据加密等方面进行检测,以期发现潜在的安全问题；</li>
<li>基于各种通信协议或相应的行业安全标准检视App是否满足相应的要求。</li>
</ul>
<h2 id="8-用户体验测试"><a href="#8-用户体验测试" class="headerlink" title="8.用户体验测试"></a>8.用户体验测试</h2><p>这个简单的说就是站在用户的角度上进行使用app，学习成本低，易上手等，可以进行用户盲测，根据用户反馈的意见进行修改。测试人员可以通过与其他竞争品进行对比， 或者根据较大厂商app的交互习惯进行比较。</p>
<h2 id="9-回归测试–一般这部分建议使用自动化测试，-如果没有自动化测试，可以根据以几方面进行测试"><a href="#9-回归测试–一般这部分建议使用自动化测试，-如果没有自动化测试，可以根据以几方面进行测试" class="headerlink" title="9. 回归测试–一般这部分建议使用自动化测试， 如果没有自动化测试，可以根据以几方面进行测试"></a>9. 回归测试–一般这部分建议使用自动化测试， 如果没有自动化测试，可以根据以几方面进行测试</h2><ul>
<li>根据产品说明书或者功能文档进行功能确认</li>
<li>重新将主要优先级较高的测试用例执行一遍</li>
<li>重新验证bug</li>
</ul>
<h2 id="10-线上测试"><a href="#10-线上测试" class="headerlink" title="10. 线上测试"></a>10. 线上测试</h2><p>线上测试是产品上线之后一定要完成的，这部分可以根据场景化进行回归测试，其中网络环境要全部覆盖一遍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/01/19/APP-Test-001/" data-id="cjl997etv00001tjyeoq19f8c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APP测试/">APP测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Charles/">Charles</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matlab/">Matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quality-Assurance/">Quality Assurance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIM/">VIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/APP测试/" style="font-size: 20px;">APP测试</a> <a href="/tags/Charles/" style="font-size: 12px;">Charles</a> <a href="/tags/Data-Structure/" style="font-size: 10px;">Data Structure</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Linux/" style="font-size: 16px;">Linux</a> <a href="/tags/Matlab/" style="font-size: 10px;">Matlab</a> <a href="/tags/Python/" style="font-size: 18px;">Python</a> <a href="/tags/Quality-Assurance/" style="font-size: 10px;">Quality Assurance</a> <a href="/tags/Shell/" style="font-size: 14px;">Shell</a> <a href="/tags/VIM/" style="font-size: 14px;">VIM</a> <a href="/tags/git/" style="font-size: 16px;">git</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/25/git-002/">git-基本操作（二）</a>
          </li>
        
          <li>
            <a href="/2018/08/24/git-001/">git-基本操作（一）</a>
          </li>
        
          <li>
            <a href="/2018/08/23/Charles-001/">Charles 重定向功能——Map Local</a>
          </li>
        
          <li>
            <a href="/2018/08/22/Charles-002/">Charles——模拟慢速网络</a>
          </li>
        
          <li>
            <a href="/2018/08/21/QA的职责/">QA的职责</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 hannie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>