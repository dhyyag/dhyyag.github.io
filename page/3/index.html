<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hannie&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="hannie's blog">
<meta property="og:url" content="http://softwaretest.cn/page/3/index.html">
<meta property="og:site_name" content="hannie's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hannie's blog">
  
    <link rel="alternate" href="/atom.xml" title="hannie&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">hannie&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://softwaretest.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GUI-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/07/GUI-001/" class="article-date">
  <time datetime="2017-06-07T07:59:48.000Z" itemprop="datePublished">2017-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/07/GUI-001/">GUI测试总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1、GUI（Graphical User Interface）图形用户界面    1<br>2、GUI设计原则    1<br>3、（Color）颜色    2<br>4、（Resource）资源    2<br>5、（Font）字体    2<br>6、（Text）文字表达    2<br>7、（STYLE）控件选择    2<br>8、（ALIGN）控件布局，窗口不拥挤，按功能组合控件    3<br>9、（TAB ORDER）TAB顺序    3<br>10、（Shortcut Key &amp; Accelerator&amp; Pop Menu） 快捷键、加速键和弹出菜单    3<br>11、（ACTION）用户交互    4<br>12、图形用户界面（GUI）的一些业界标准    4<br>13、通用界面元素设计与测试    5<br>14、菜单的设计与测试    6<br>15、系统响应时间    6<br>16、（MessageBox） 消息框。    7<br>17、美学方面测试    7<br>18、确认正确性    8<br>19、导航测试    8<br>20、元素易用性测试    8<br>21、数据完整性测试    9<br>22、只读模式的测试    9<br>23、通用性测试    9<br>24、日期域的测试    10<br>25、数字域的测试    10<br>26、字符域的测试    11</p>
<h2 id="1、GUI（Graphical-User-Interface）图形用户界面"><a href="#1、GUI（Graphical-User-Interface）图形用户界面" class="headerlink" title="1、GUI（Graphical User Interface）图形用户界面"></a>1、GUI（Graphical User Interface）图形用户界面</h2><p>1.1、UI设计从工作内容上来说分为3个方向 ：<br>图形设计Graphic Design<br>交互设计 Interaction Design<br>用户研究User experience engineer<br>1.2、一些专家指出：对于用户，人机界面就是系统本身。界面问题虽“小”，只是“小”在它不影响功能的正确使用，但是影响的往往是用户对产品的印象和用户操作软件的效率，从而直接影响了用户的工作的效率。界面测试可以降低对用户有关软件产品培训和技术支持的费用。</p>
<h2 id="2、GUI设计原则"><a href="#2、GUI设计原则" class="headerlink" title="2、GUI设计原则"></a>2、GUI设计原则</h2><p>● 关注用户及其任务，而不是技术<br>● 首先考虑功能，然后才是表示<br>● 确定用户对任务的看法<br>● 不要让用户任务复杂化<br>● 促进学习<br>● 传递信息，而不仅仅是数据<br>● 设计应满足响应需求<br>● 针对用户进行充分测试，然后进行修补</p>
<h2 id="3、（Color）颜色"><a href="#3、（Color）颜色" class="headerlink" title="3、（Color）颜色"></a>3、（Color）颜色</h2><p>● 统一色调，采用标准Windows的基本色调，做到与操作系统统一，读取系统标准色表。<br>● 整个界面色彩尽量少的使用类别不同的颜色。除非特殊场合，杜绝使用对比强烈，让人产生憎恶感的颜色。<br>● 同时色调也具有一定的含义，在整个系统中应保持色调含义的一致性，避免同一中颜色在不同的画面中表示不同的意义。</p>
<h2 id="4、（Resource）资源"><a href="#4、（Resource）资源" class="headerlink" title="4、（Resource）资源"></a>4、（Resource）资源</h2><p>● 计算机的资源包括图标资源和鼠标光标资源等。<br>● 图标资源也需要遵循统一的规则，因为不同的图标代表不同的意义。例如：我们用图标来表示保存，因此我们在整个系统中只要涉及到保存的话,都应该使用同一个图标，不论是用在工具栏上还是在菜单上,还是在按钮上。<br>● 图标、图像应该很清晰的表达出意思，遵循常用标准，或者用户机器容易联想的到物件，绝对不允许画出默认奇妙的图案。<br>● 鼠标光标样式统一，使用系统标准。注意：本系统中不采用窗体做进度条，对于点击按钮后，鼠标变成沙漏形状，执行完成后, 鼠标变回。</p>
<h2 id="5、（Font）字体"><a href="#5、（Font）字体" class="headerlink" title="5、（Font）字体"></a>5、（Font）字体</h2><p>● 系统中中文一律采用标准字体“宋体”，英文一律采用标准 Microsoft Sans Serif ，除登录界面和图标中的特殊字体用图片实现,原则上不考虑特殊字体（隶书、草书等,特殊情况可以使用图片取代）,保证每个用户使用起来显示都很正常。<br>● 字体大小统一规定， MSS字体8磅，宋体为10磅，字体颜色一般采用系统默认颜色。<br>所有控件尽量使用大小统一的字体属性，除了特殊提示信息、加强显示等例外情况。</p>
<h2 id="6、（Text）文字表达"><a href="#6、（Text）文字表达" class="headerlink" title="6、（Text）文字表达"></a>6、（Text）文字表达</h2><p>● 使用统一的语言描述，提到同一个概念时，用相同的术语描述。例如一个关闭退出功能按钮，统一描述为关闭，避免使用返回、退出描述。<br>● 通常情况下，每个窗口应该有一个唯一的标题，和触发它的菜单或按钮命令相对应。<br>● 在提示信息中多用“您、请”等礼貌用语，不要用对用户来说晦涩的计算机用语，杜绝错别字。<br>● 断句逗号句号顿号分号的用法，提示信息比较多的话，应该分段。<br>● 错误消息对话框不仅仅指出问题，还要提供解决问题的建议。</p>
<h2 id="7、（STYLE）控件选择"><a href="#7、（STYLE）控件选择" class="headerlink" title="7、（STYLE）控件选择"></a>7、（STYLE）控件选择</h2><p>● 不要随意使用控件，控件功能要专一，风格统一。如果没有好的控件，则使用标准控件。<br>控件的风格统一。<br>● 同一类型的控件操作方式相同，避免出现一个控件双击可以执行某些动作，而同样控件，双击却没有任何反映。<br>● 一个控件只做单一功能，尽量不复用。</p>
<h2 id="8、（ALIGN）控件布局，窗口不拥挤，按功能组合控件"><a href="#8、（ALIGN）控件布局，窗口不拥挤，按功能组合控件" class="headerlink" title="8、（ALIGN）控件布局，窗口不拥挤，按功能组合控件"></a>8、（ALIGN）控件布局，窗口不拥挤，按功能组合控件</h2><p>● 屏幕不能拥挤，让人看上去，不能太拥挤，也不能太松散。<br>● 整个项目，尽量采用统一的控件间距，通过调整窗体大小达到一致，即使在窗体大小不变的情况下，宁可留空部分区域，也不要破坏控件间的行间距。<br>● 文字和文本框一般采用左对齐方式，如单行文本框前的标签提示，使用左对齐加冒号；数据列表表头文字和内容，也采用左对齐。文字和文本框中的文字水平中对齐。横排按钮，最右边的一个与上面的控件右对齐窗口缩放时，控件位置、布局。<br>● 为了使界面不出现跑版或者难看的局面，解决方法是固定窗口大小，不允许改变尺寸。<br>● 弹出窗口有唯一的标题，和触发它的菜单或按钮命令相对应。<br>● 间距与对齐示例 </p>
<h2 id="9、（TAB-ORDER）TAB顺序"><a href="#9、（TAB-ORDER）TAB顺序" class="headerlink" title="9、（TAB ORDER）TAB顺序"></a>9、（TAB ORDER）TAB顺序</h2><p>● 习惯用法，阅读顺序，从左到右，从上到下。</p>
<h2 id="10、（Shortcut-Key-amp-Accelerator-amp-Pop-Menu）-快捷键、加速键和弹出菜单"><a href="#10、（Shortcut-Key-amp-Accelerator-amp-Pop-Menu）-快捷键、加速键和弹出菜单" class="headerlink" title="10、（Shortcut Key &amp; Accelerator&amp; Pop Menu） 快捷键、加速键和弹出菜单"></a>10、（Shortcut Key &amp; Accelerator&amp; Pop Menu） 快捷键、加速键和弹出菜单</h2><p>● 使用非破坏性缺省按钮，回车、ESC键的正确使用。对于弹出模态窗体，有默认加速键，如回车表示激活当前窗口设置为default的按钮动作，esc表示关闭窗口。同时在调用default按钮动作和关闭动作时候，不应该做有破坏性的操作，避免用户错误操作产生危害程度，例如不能把删除数据等功能的按钮作为缺省按钮。当用户要提交很多数据时，应该屏蔽ESC，或者做退出提示，告诫用户是否保存提交。<br>● 尽量避免使用右键菜单， 如使用的话尽量在可视化界面上拥有对应的按钮或者菜单选项。因为右键菜单由用户点击鼠标左右键或者别的动作才能调出来显示给用户。无法清晰的显示给用户，所以对应选项应该可以通过别的途径得到的。</p>
<h2 id="11、（ACTION）用户交互"><a href="#11、（ACTION）用户交互" class="headerlink" title="11、（ACTION）用户交互"></a>11、（ACTION）用户交互</h2><p>● 要使一个功能有时允许有时不允许用户使用，则这个控件的不能随便隐藏，应该使用disable属性进行表示，以免用户发现控件失踪后措手无策。<br>● 窗口弹出位置要明显，点击一个控件，弹出窗口或者菜单，应该给人明显提示。对于弹出窗体,统一要求显示位置在屏幕中央，要求窗体是以模态显示，并且不出现在任务拦上。<br>● 执行动作要有提示。UI作为人机对话的工具，用户做了任何动作，应该给用户一个视觉或者听觉、触觉提示。而且这个提示应该行明显，但不应提示过长，可以有以下几种方法：弹出交互对话框让用户点击确认；    改变UI中控件参数提示：（处理不用用户确认的提示，有一定延时，或者用户按键后自动清除。）；改变标题栏字符串，显示“信息：提交成功”,或者专门设置一个状态栏、TLable等用来进行提示。 </p>
<h2 id="12、图形用户界面（GUI）的一些业界标准"><a href="#12、图形用户界面（GUI）的一些业界标准" class="headerlink" title="12、图形用户界面（GUI）的一些业界标准"></a>12、图形用户界面（GUI）的一些业界标准</h2><p>1对于每个应用程序（Application）<br>● 在图形上双击启动应用：装入信息应显示应用名、版本号，以及以大图形代替原来的图形；<br>● 关闭应用时应有信息窗提示用户确认：“您确认要退出<em>*</em>？”；<br>● 试图同时打开两次应用时不允许，当应用正在装载时试一下第二次开启应用；（一般而言）<br>所有的屏幕都应响应帮助【F1】键且做同样的工作（显示相应的帮助信息）</p>
<p>2 对于应用中的每个窗口<br>● 如果窗口有最小化按钮，点一下它，应最小化到任务栏，且显示相应的图标; 再次单击这个图标，可以返回到窗口并恢复到窗口原有的大小；<br>● 窗口控件的大小、对齐方向、颜色、背景等属性的设置值是否和标准要求的一致；<br>● 检查窗口中的下拉菜单、工具条、滚动条、对话框、按钮、图标和其他控制的功能，是否错用窗口元素、是否符合标准要求；</p>
<p>3 对于应用中的每个窗口<br>● 使用【TAB】键在窗口中移动光标/焦点，使用【Shift】+【Tab】组合键回移；<br>● 屏幕中各元素得到焦点的次序应从左到右，从上到下；<br>● 如果一个钮能产生一个新窗口，则它不应盖住先前的窗口，并能回到先前的窗口中；<br>● 一般情况下，窗口中的所有事情应既能用鼠标又能用键盘来完成。</p>
<h2 id="13、通用界面元素设计与测试"><a href="#13、通用界面元素设计与测试" class="headerlink" title="13、通用界面元素设计与测试"></a>13、通用界面元素设计与测试</h2><p>1、文本框（Text Boxes）   </p>
<p>● 不要使用文本输入框来显示只读数据和信息。只读信息的文本框应该底色变灰，并且去掉文本框边框，和可编辑但未激活的状态区别开来。<br>● 给日期，数字，单位等特殊文字选择框或特殊文本框，检测到非法输入后应给出说明并能自动获得焦点。</p>
<p>2、单选钮（Radio Buttons）<br>● 用左右键和上下键移动，或以及鼠标单击选中。<br>● 单选框是一种多选一设置，可选数目在2-8之间。<br>● 当空间不够时，单选框可以用循环按钮、下拉菜单、滚动列表框来代替。</p>
<p>3、复选框（Check Boxes） 　　　<br>● 在框中用鼠标单击，或在文本上设置/取消设置，试着用空格键做这件事。<br>● 复选框和选项框按选择几率的高底而先后排列。<br>● 复选框和选项框要有默认选项，并支持Tab选择。</p>
<p>4、命令钮（Command Buttons）<br>● 如果它能导出一个新的窗口，使用户能输入或改变内容，则按钮的文字后带省略号（3个小点）；<br>● 除确定（ok）或取消（Cancel）外，其他的按钮应有一个字符代表，这个字符在按钮上是以下划线表示的，用[ALT]+字符组合键的方式可激活它，保证不重复定义这类字符；<br>● 用鼠标单击每一个按钮，应能激活；<br>● 用[Tab]走到这个按钮后，按[空格]或[Enter]键应能激活；<br>● 用[Tab]移到其他类型的控制按钮（非命令），则在屏上这个控制钮以加宽黑框表示，这时按Enter应能激活这个控制钮；<br>● 按[Esc]键应能激活[Cancel]钮。</p>
<p>5、下拉列表框（Drop Down List Boxes）<br>● 按下拉列表框右边的箭头处，应能得到（打开）选择列表项，列表项可以卷动（当内容多时应有卷动条），其框中应不能输入文本；<br>● 按一个字符应到以这个字符开头的项（英文时），按[Ctrl]+[F4]组合键应能打开下拉列表框。<br>● 下拉列表框中的选项应是排好了序的。</p>
<p>6、联合框（Combo Boxes）<br>● 与下拉列表框的区别是，联合框中既可以输入文字，又可以在列表中选择。<br>列表框（List Boxes）<br>● 用鼠标单击或上下箭头键可以选中一项；<br>● 用卷动条可看到所有的数据。</p>
<h2 id="14、菜单的设计与测试"><a href="#14、菜单的设计与测试" class="headerlink" title="14、菜单的设计与测试"></a>14、菜单的设计与测试</h2><p>● 菜单是应用程序命令项的列表，菜单可以是多级，这时是按照功能来组织的。菜单可以有多种形式，如：条形菜单、水平和垂直的弹出式菜单、下拉菜单等。<br>● 菜单功能是否正确执行；<br>● 常用菜单要有命令快捷方式。<br>● 文本字体、大小和格式是否正确；<br>● 菜单功能的名字是否具有自解释性;<br>● 右键快捷菜单是否采用与菜单相同的准则；<br>● 是否适当地列出了所有的菜单功能<br>● 是否根据系统功能进行合理分类，将选项进行分组（完成相同或相近功能的菜单用横线隔开放在同一位置。）；<br>● 菜单深度是否控制在3层以内<br>● 菜单标题是否简洁、有意义；菜单前的图标能直观的代表要完成的操作，如不能则不要用图标。<br>● 是否依使用频度排列；是否依逻辑顺序排列；是否依使用顺序排列；<br>● 各级菜单显示格式和操作方式是否一致。</p>
<h2 id="15、系统响应时间"><a href="#15、系统响应时间" class="headerlink" title="15、系统响应时间"></a>15、系统响应时间</h2><p>● 系统响应时间包括两个方面：时间长度和时间的易变性。用户响应时间应该适中，系统响应时间过长，用户就会感到不安和沮丧，而响应时间过短有时会造成用户加快操作节奏，从而导致错误。在系统响应时间上坚持如下原则：<br>  响应时间长度      界面设计<br>  0-10 秒           鼠标显示成为沙漏<br>  10 到18 秒        由微帮助来显示处理进<br>  18 秒 以 上       显示处理窗口，或显示进度条<br>● 对可能造成等待时间较长的操作最好提供取消功能。<br>● 当一个长时间的处理完成时应发出一个提示警告声如beep（1）， 这样用户不必总看着屏幕。</p>
<h2 id="16、（MessageBox）-消息框。"><a href="#16、（MessageBox）-消息框。" class="headerlink" title="16、（MessageBox） 消息框。"></a>16、（MessageBox） 消息框。</h2><p>● 标题：建议以主窗口的名称作为标题，以变量的形式显示，最好不要写死。（标题是否根据内容显示为“提示”，“警告”）<br>● 文本：不考虑国际化开发时，可以直接以中文显示，考虑国际化开发时，需要根据字串取本地化文本。请注意提示信息的语气及标点符号。<br>● 按钮：当有多个按钮时，执行删除操作时，默认按钮应为否（取消）。<br>● 符号：根据提示的内容，确认图标的显示。<br>● 根据提示的内容，确认图标的显示</p>
<h2 id="17、美学方面测试"><a href="#17、美学方面测试" class="headerlink" title="17、美学方面测试"></a>17、美学方面测试</h2><p>● 屏幕/窗口的背景色是否正确；<br>● 图标基调颜色、大小。布局是否协调；<br>● 图标的外形与实际功能的相似性，尽量避免抽象；<br>● 重要的命令按钮与使用较频率的按钮是否放在了界面上醒目的位置；<br>● 域提示的颜色是否正确；<br>● 域背景色是否正确；<br>● 只读模式下，域提示的颜色是否正确；<br>● 只读模式下，域背景色是否正确；<br>● 屏幕中提示的字体是否正确；<br>● 域中文本的字体是否正确；<br>● 域的排列是否美观；<br>● 域的编辑框排列是否美观；<br>● 成组的框的排列是否美观；<br>● 按钮的大小与界面的大小和空间是否协调；<br>● 屏幕窗口是否可极小化<br>● 屏幕窗口是否可以恢复大小；<br>● 域提示的拼写是否正确；<br>● 字符或字母域的对齐方式是否正确；<br>● 数字域的对齐方式是否正确；<br>● 屏幕窗口中的帮助提示文本中是否有错别字；<br>● 屏幕窗口中错误信息文本中是否也有错别字；<br>● 文本中英文字符的大小写是否敏感；<br>● 域中是否有缺省值；<br>● 保证所有窗口看上去或感觉上，具有一致性；<br>● 保证所有的会话框看上去或感觉上，具有一致性；</p>
<h2 id="18、确认正确性"><a href="#18、确认正确性" class="headerlink" title="18、确认正确性"></a>18、确认正确性</h2><p>● 每个域中确认有问题时，是否给用户一个恰当的信息；<br>● 是否要求用户对一个已确认的错误域进行修改；<br>● 当域有多项检查规则，进行覆盖测试；<br>● 在域中输入非法值并单击了[确认]按钮后，是否会出现报错信息；<br>● 保持屏幕/窗口级的一致性（除特殊要求外）；<br>● 对于数字域，检查负数是否能输入；<br>● 对于数字域，检查最大值、最小值，以及中间值是否允许；<br>● 对字符/字母域检查是否有一个特定的限制；<br>● 检查必输域是否需要用户输入；<br>● 必输域对应的数据库表字段是否不能为空；</p>
<h2 id="19、导航测试"><a href="#19、导航测试" class="headerlink" title="19、导航测试"></a>19、导航测试</h2><p>● 通过菜单是否可以进入应用屏（窗口）；<br>● 通过工具条是否可以进入应用屏（窗口）；<br>● 通过父窗口中的按钮是否可以进入子窗口；<br>● 可以双击父窗口的列表控制是否可以进入子窗口；<br>● 当窗口激活时，窗口模式是否正确；<br>● 同时能打开相同应用窗口的数量是否符合要求；</p>
<h2 id="20、元素易用性测试"><a href="#20、元素易用性测试" class="headerlink" title="20、元素易用性测试"></a>20、元素易用性测试</h2><p>● 窗口中下拉表中的项目排序是否正确，一般以字母升序作为缺省情况；<br>● 测试日期输入的正确格式；<br>● 窗口中的按钮是否都有适当的快捷键；<br>● 快捷键的工作是否正常；<br>● 菜单中的选项是否定义了快捷键；<br>● 用【Tab】键在元素间移动的次序是否正确，一般缺省为从左上到右下；<br>● 只读域应不在TAB键能达到的序列中；<br>● 非激活域应不在TAB键能达到的序列中；<br>● 用鼠标点出文本框，是否会出现帮助信息；<br>● 用鼠标单击只读域，是否能进入；<br>● 当打开窗口时，光标/焦点应位于第一个可输入域；<br>● 窗口中是否有缺省的按钮定义；<br>● 缺省按钮的工作是否正常；<br>● 当错误信息确认时，焦点是否会回到出错的域；<br>● 使用【Alt】＋【Tab】组合键从一个应用到另一个应用切换时是否有冲突；<br>● 编辑框域是否指示了字符的长度；</p>
<h2 id="21、数据完整性测试"><a href="#21、数据完整性测试" class="headerlink" title="21、数据完整性测试"></a>21、数据完整性测试</h2><p>● 关闭窗口时数据是否得到了保存；<br>● 检查域的长度，以保证没有字样被截掉；<br>● 有的域是通过在数据库中查询一个值作为缺省值，并且用户可以输入一个有效值来取代这个值；<br>● 检查数字域的最大值和最小值；<br>● 检查能接受负数的数字域能将负数正确的存储；<br>● 一组单选按钮是否由一组值代表（在数据库中）；<br>● 数据库对数据的存储是否完整，如字符串是否被截，数值是否被舍入。</p>
<h2 id="22、只读模式的测试"><a href="#22、只读模式的测试" class="headerlink" title="22、只读模式的测试"></a>22、只读模式的测试</h2><p>● 只读模式屏幕和域的颜色设置是否正确；<br>● 只读模式是否合乎实际（这种情况下，是否应设为只读模式）；<br>● 字段域和控制按钮是否以只读模式来表示非激活；<br>● 与正在进行的操作无关的按钮应加以屏蔽（只读模式）<br>● 从窗口/菜单/工具条的只读模式是否能进入下一级窗口；<br>● 从只读模式进入的窗口是否有效；<br>● 只读模式下不能执行或进行“确认”；</p>
<h2 id="23、通用性测试"><a href="#23、通用性测试" class="headerlink" title="23、通用性测试"></a>23、通用性测试</h2><p>● 保证有“帮助”菜单的存在；<br>● 保证在每个菜单中有适当的命令或先项；<br>● 保证工具条中的所有按钮对应一个命令；<br>● 保证每个菜单命令有一个热键方式；<br>● 在下拉列表中，保证值不被截断；<br>● 在下接列表中，保证表中的条目能通过适当的键或热键联合来存取；<br>● 窗口中没有重复定义的热键；<br>● 保证[Esc]键的正确使用（常用于“取消”），应有类似的提示：“更新的数据将丢失 是否继续？”；<br>● 保证“取消”按钮的功能同［Esc］键；<br>● “取消”但不能回退（已作的变化不能回退）时，应相当于“关闭”；<br>● 保证隐藏于当前屏幕后上的命令按钮不能工作；<br>● 当一个命令按钮应根据情况来确定是否能使用时，应保证在不能使用时变灰；<br>● 保证“确认［ＯＫ］”键和“取消［Cancel］”键按钮成对，并与其它命令按钮分开；<br>● 保证命令按钮名字清楚；<br>● 保证字段域的标签或名字不过于专业性，而是对系统的用户有意义的；<br>● 保证命令按钮有相似的大小和形状，相同的字体和字体大小；<br>● 保证每个按钮能通过热键盘方式来访问；<br>● 保证命令按钮在同一个窗口／会话框中不会重复；<br>● 保证每个窗口／会话框中元素（命令按钮、其它元素）在按回车键时，有一个清晰的缺省值响应回车；<br>● 保证对象／按钮的设置对应于窗口／会话框需要的功能；<br>● 保证可选按钮（包括单选项、复选项、以及选择框）的名字清楚；<br>● 保证可选按钮的名字不过于专业性，而是对系统的使用者有意义；<br>● 如果热键用于访问可选键，保证在同一窗口／会话框中，热键不重复；<br>● 保证选择窗、选择按钮和命令按钮被逻辑地组在一起，形成功能“组”；<br>● 保证使用[Tab]键（序列）逻辑地在屏幕的域中移动光标；<br>● 保证在窗口中、鼠标中的一致性；<br>● 红色不用于加亮被激活的元素（色盲中最常风的为红-绿色盲）；<br>● 保证屏幕／窗口中的展现与分布不混乱；<br>● 在表窗口中[Ctrl]+[F6]组合键打开下一个表；<br>● 在表窗口中[Shift]+[Ctrl]+[F6]组合键打开先前的表（回到先前的表）；<br>● 在当前表的最后域中，用[Tab]键可以打开下一个表；<br>● 在最后表的最后域中，用[Tab]键可以走到［继续］按钮中；<br>● 在窗口中间件［Tab］键可走进下一个可编辑框；<br>● 标识的风格、大小、展现与现有的窗口一致；<br>● 当列表框中的选项少于8项时，不必用滚动条；<br>● 当系统“继续”发现错误时，应回到出错的域或表；<br>● 对表中的域输入正确前，按[继续]按钮不起作用；<br>● 打开一个表时，焦点落入第一个可编辑域；<br>● 所有字体一致；<br>● ［Alt］+[F4]组合键将关闭表窗口，回到主屏幕或先前的屏幕，必要时有提示信息：如“更新的数据将丢失”；<br>● 对于激活的域和挖掘有简单的帮助文本；<br>● 保证所有非激活域是只读模式。 </p>
<h2 id="24、日期域的测试"><a href="#24、日期域的测试" class="headerlink" title="24、日期域的测试"></a>24、日期域的测试</h2><p>● 保证闰年日期有效正确，不产生错误和计算误差；<br>● 测试月份是在1和12之间（含），保证00和12报告错误；<br>● 测试日期在1和31之间（含），最大值与月份相关；<br>● 对二月的28,29,30日，进行验证；<br>● 测试日期的周期性计算正确。</p>
<h2 id="25、数字域的测试"><a href="#25、数字域的测试" class="headerlink" title="25、数字域的测试"></a>25、数字域的测试</h2><p>● 保证对最低、最高值处理正确；<br>● 输入无效的数据值被记录和报告；<br>● 保证有效的值被正确地处理<br>● 在数字前面带有空格的数字域被正确处理还是报错误；<br>● 在数字后面带有空格的数字域被正确处理还是报错误；<br>● 保证正、负值被正确处理；<br>● 保证除零的事不会发生；<br>● 数字域范围至少含有一个值<br>● 数字域范围含最大值和最小值<br>● 对范围处的值进行测试，保证错误值能被检测出来。</p>
<h2 id="26、字符域的测试"><a href="#26、字符域的测试" class="headerlink" title="26、字符域的测试"></a>26、字符域的测试</h2><p>● 测试使用空格和非空格字符；<br>● 测试最高值和最低值<br>● 测试非法字符或控制符<br>● 测试合法字符<br>● 测试第一个位置是空格的数据或最后一位置是空格的数据。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/07/GUI-001/" data-id="cjl99ljwi000insjyyrhvlepm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-002" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/07/Linux-002/" class="article-date">
  <time datetime="2017-06-07T00:05:40.000Z" itemprop="datePublished">2017-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/07/Linux-002/">Linux-常用命令（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="8-查系统和用户信息"><a href="#8-查系统和用户信息" class="headerlink" title="8. 查系统和用户信息"></a>8. 查系统和用户信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uname -a  #会显示当前操作系统的所有信息。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hostname  #会显示主机的名称</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whoami    #会显示当前操作的用户</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">who       #会显示在线登陆的用户</div></pre></td></tr></table></figure>
<h2 id="9-清除屏幕-clear"><a href="#9-清除屏幕-clear" class="headerlink" title="9. 清除屏幕-clear"></a>9. 清除屏幕-clear</h2><p>若屏幕上的内容太多，可以使用clear清除屏幕<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clear     #清除屏幕</div></pre></td></tr></table></figure></p>
<h2 id="10-与文件目录相关的命令（一）"><a href="#10-与文件目录相关的命令（一）" class="headerlink" title="10. 与文件目录相关的命令（一）"></a>10. 与文件目录相关的命令（一）</h2><p>命令1：pwd（功能：显示当前目录的路径）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pwd    #显示当前目录的绝对路径</div></pre></td></tr></table></figure></p>
<p>命令2：cd（功能：切换到指定的目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd  /usr/bin   #从当前目录切换到/usr/bin子目录下</div><div class="line">cd ..          #从当前目录切换到上一层目录</div></pre></td></tr></table></figure></p>
<p>命令3：ls（功能：显示指定目录中的文件和子目录信息）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ls                        #显示当前目录下的文件和子目录信息</div><div class="line">ls -l                     #显示当前目录下的文件和子目录详细信息</div><div class="line">ls -l /home/eric/dhyblog  #显示指定的目录/home/eric/dhyblog下的所有文件和子目录的详细信息。</div></pre></td></tr></table></figure></p>
<p>命令4：cat（功能：显示文本文件内容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat 1.txt                #显示1.txt文本中的内容</div><div class="line">cat -n 1.txt             #显示1.txt文本中的内容，并且在每一行前显示行号。</div><div class="line">cat -n /home/eric/1.txt  #显示指定目录/home/eric下的1.txt文本中的内容，并且在每一行前显示行号。</div><div class="line">cat /etc/shells          #显示当前主机中的所有shell类型。</div></pre></td></tr></table></figure></p>
<p>命令5：more（功能：分屏显示文本总的内容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">more 1.txt  #若1.txt中的内容特别多，可以分屏显示。</div></pre></td></tr></table></figure></p>
<p>命令6：mkdir（功能：创建新的子目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir myfile             #在当前目录下创建了新的子目录myfile。</div><div class="line">mkdir /home/eric/myfile  #在指定的目录/home/eric下创建新的子目录myfile。</div></pre></td></tr></table></figure></p>
<p>命令7：rmdir（功能：删除空目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rmdir myfile             #若目录myfile为空则删除该目录。</div><div class="line">rmdir /home/eric/myfile  #删除指定目录/home/eric下的空目录myfile</div><div class="line">rmdir -p myfile          #当子目录myfile被删除后，当前的目录若也为空则一起删除。</div></pre></td></tr></table></figure></p>
<p>命令8：cp（功能：复制一个文件到另一个文件中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp 源文件 目标文件       #将源文件中的文件复制到目标文件中</div><div class="line">cp -r 源文件 目标文件    #将源文件中的文件复制到目标文件中，若源文件中有目录，则将目录下的文件也一起复制到目标文件中。</div></pre></td></tr></table></figure></p>
<p>命令9：mv（功能：移动一个文件到另一个文件中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv 源文件  目标文件      #将源文件中的文件移动到目标文件中</div><div class="line">mv -i 源文件 目标文件    #将源文件中的文件移动到目标文件中，若目标文件中已有同名文件则询问是否覆盖。</div></pre></td></tr></table></figure></p>
<p>命令10：rm（功能：删除文件及目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rm myfile    #删除myfile文件</div><div class="line">rm -i myfile #删除myfile中的文件时逐一询问是否删除</div><div class="line">rm -r myfile #删除myfile目录，目录下的文件也逐一删除</div><div class="line">rm -f myfile #若myfile文件为只读文件，也进行删除。</div></pre></td></tr></table></figure></p>
<p>（待续…………）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/07/Linux-002/" data-id="cjl99ljwq000nnsjyiki0x0hh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/Linux-001/" class="article-date">
  <time datetime="2017-06-06T13:25:53.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/Linux-001/">Linux-常用命令（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-打开终端"><a href="#1-打开终端" class="headerlink" title="1. 打开终端"></a>1. 打开终端</h2><p>法一：键盘输入Ctrl+Alt+T<br>法二：Alt+F2   之后输入gnome_terminal</p>
<h2 id="2-进入root（超级用户）"><a href="#2-进入root（超级用户）" class="headerlink" title="2. 进入root（超级用户）"></a>2. 进入root（超级用户）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">——&gt; sudo su</div><div class="line">[sudo]password for eric:    #须在此处输入密码，但输入的密码不会显示在屏幕上</div><div class="line">root@eric-pc:               #当显示root@后就代表已经进入了root</div></pre></td></tr></table></figure>
<h2 id="3-退出root"><a href="#3-退出root" class="headerlink" title="3. 退出root"></a>3. 退出root</h2><p>直接输入exit就可以退出root。</p>
<h2 id="4-与-的区别："><a href="#4-与-的区别：" class="headerlink" title="4. $与#的区别："></a>4. $与#的区别：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ 表示当前用户为普通用户</div><div class="line"># 表示当前用户为超级用户</div></pre></td></tr></table></figure>
<p>（ps：在python和shell中，以#开头的文本作为注释行）</p>
<h2 id="5-重启电脑"><a href="#5-重启电脑" class="headerlink" title="5.重启电脑"></a>5.重启电脑</h2><p>法一：进入root后，键入reboot            #表示立即重启<br>法二：进入root后，键入shutdown -r now   #表示立即重启<br>法三：进入root后，键入shutdown -r 5     #表示5分钟后自动重启<br>法四：进入root后，键入shutdown -r 20:30 #表示在20:30时自动重启<br>（若想取消设置的重启，则可键入shutdown -e）</p>
<h2 id="6-关机"><a href="#6-关机" class="headerlink" title="6. 关机"></a>6. 关机</h2><p>法一：进入root后，键入halt            #表示立即关机<br>法二：进入root后，键人poweroff        #表示立即关机<br>法二：进入root后，键入shutdown -h now   #表示立即关机<br>法三：进入root后，键入shutdown -h 5     #表示5分钟后自动关机<br>法四：进入root后，键入shutdown -h 20:30 #表示在20:30时自动关机<br>（若想取消设置的关机，则可键入shutdown -e）</p>
<h2 id="7-需要帮助"><a href="#7-需要帮助" class="headerlink" title="7. 需要帮助"></a>7. 需要帮助</h2><p>在需要帮助时记得用man和help<br>法一：键入：man 命令名，就可以显示该命令的帮助文档。<br>      想退出帮助文档时键入 q 即可。<br>法二：键入：命令名 –help，就可以显示该命令的帮助。<br>      例如：cat –help<br>法三：help 命令名，可用于查找shell内部命令的帮助文档。<br>      键入：bash    #进入了bash（bash是linux系统默认使用的shell类型，常用的还有zsh csh ksh ash）<br>      键入：help cd #查找cd命令的帮助文档<br>      键入：exit    #退出bash</p>
<p>（待续…………）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/06/Linux-001/" data-id="cjl99ljwk000knsjy7qlw3lrc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Echo-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/Echo-001/" class="article-date">
  <time datetime="2017-06-06T12:09:25.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/Echo-001/">终端打印-echo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-终端打印-echo"><a href="#一-终端打印-echo" class="headerlink" title="一. 终端打印-echo"></a>一. 终端打印-echo</h2><p>特点：每次调用之后会自动添加一个换行符<br>1、可以使用 -n 来忽略结尾的换行符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo -n &quot;hello&quot;</div><div class="line">hello</div></pre></td></tr></table></figure></p>
<p>2、可以使用 -e 来使用转义序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;1\t2\t3\t&quot;</div><div class="line">1	2	3</div></pre></td></tr></table></figure></p>
<h2 id="二-终端打印-printf"><a href="#二-终端打印-printf" class="headerlink" title="二. 终端打印-printf"></a>二. 终端打印-printf</h2><p>特点：每次调用时不会自动添加换行符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ printf &quot;hello&quot;</div><div class="line">hello</div></pre></td></tr></table></figure></p>
<h2 id="三-终端打印的小应用"><a href="#三-终端打印的小应用" class="headerlink" title="三. 终端打印的小应用"></a>三. 终端打印的小应用</h2><p>1、要打印彩色背景的文本：黑=40 红=41 绿=42 黄=43 蓝=44 重置=0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;\e[1;42m green background \e[0m&quot;</div></pre></td></tr></table></figure></p>
<p>2、要打印彩色的文本：黑=30 红=31 绿=32 黄=33 蓝=34 重置=0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;\e[1;31m this is red text \e[0m&quot;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/06/Echo-001/" data-id="cjl99ljwh000fnsjyzazmj5et" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vim-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/vim-001/" class="article-date">
  <time datetime="2017-06-06T11:37:44.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/vim-001/">vim的三种模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-普通模式："><a href="#一-普通模式：" class="headerlink" title="一. 普通模式："></a>一. 普通模式：</h2><p>1、通过以下命令进入的则是普通模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim 1.txt   #1.txt为要编辑的文档。若该文档存在时则直接打开编辑，若该文档不存在则新建1.txt文档后打开编辑。</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim -R 1.txt  #以只读模式打开文件1.txt</div></pre></td></tr></table></figure>
<p>2、当在“输入模式”或者“命令模式”时，按键盘左上角的“Esc”可回到普通模式。<br>3、在普通模式下，通常会进行复制，粘贴，移动，删除等操作。</p>
<h2 id="二-插入模式："><a href="#二-插入模式：" class="headerlink" title="二. 插入模式："></a>二. 插入模式：</h2><p>1、进入普通模式后，再输入i或a或o或I或A或O，均可进入插入模式。<br>2、若在命令模式中，要想进入插入模式，需要先按下按键“Esc”回到普通模式后，再进入插入模式。<br>3、在插入模式下，通常进行输入字符操作。</p>
<h2 id="三-命令模式："><a href="#三-命令模式：" class="headerlink" title="三. 命令模式："></a>三. 命令模式：</h2><p>1、若目前在普通模式下，想要进入命令模式，需要键入：（冒号）可进入命令模式。<br>2、若目前在插入模式下，想要进入命令模式，需要按下按键“ESC”回到普通模式后，再进入命令模式。<br>3、在命令模式下，通常进行保存该文档，或退出vim，或对vim编辑器做一些设置，或运行lunux命令等操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/06/vim-001/" data-id="cjl99ljxj001qnsjywaaftwcm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VIM/">VIM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shell-003" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/04/shell-003/" class="article-date">
  <time datetime="2017-06-04T12:52:45.000Z" itemprop="datePublished">2017-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/shell-003/">shell是什么？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、shell是什么？"><a href="#一、shell是什么？" class="headerlink" title="一、shell是什么？"></a>一、shell是什么？</h2><p>shell 的本意是“壳”的意思。形象的说明了shell是围绕在Linux内核之外的一个“壳”程序。shell是用户和操作系统内核之间通讯的桥梁。<br>shell是一种<strong>命令解释程序</strong>：它解释用户输入的命令，然后提交为内核处理，最后把结果返回给用户。<br>shell是一种<strong>解释型的程序设计语言</strong>：它定义了各种选项和变量，有函数，表达式，循环等，可以利用shell编写shell 脚本。</p>
<h2 id="二、Linux下有很多shell"><a href="#二、Linux下有很多shell" class="headerlink" title="二、Linux下有很多shell"></a>二、Linux下有很多shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cat /etc/shells  #查看系统下的所有shell</div><div class="line"></div><div class="line">/bin/bash</div><div class="line">/bin/csh</div><div class="line">/bin/ksh</div><div class="line">/bin/sh</div><div class="line">/bin/tcsh</div><div class="line">/bin/zsh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo $SHELL     #查看当前用户默认使用的shell</div><div class="line"></div><div class="line">/bin/zsh       #我的系统默认使用的是zsh</div></pre></td></tr></table></figure>
<h2 id="三、shell命令的语法"><a href="#三、shell命令的语法" class="headerlink" title="三、shell命令的语法"></a>三、shell命令的语法</h2><p>比如 cd pwd exit echo等命令是bash的内置命令，当用户登录系统后，shell以及内置的命令就被系统载入到内存中，并且一直运行，直到用户退出程序为止。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/06/04/shell-003/" data-id="cjl99ljxi001onsjy14viwhs9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/">Shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-005" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/05/APP-Test-005/" class="article-date">
  <time datetime="2017-03-05T09:23:55.000Z" itemprop="datePublished">2017-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/05/APP-Test-005/">APP测试总结（五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="测试文档编写与缺陷管理"><a href="#测试文档编写与缺陷管理" class="headerlink" title="测试文档编写与缺陷管理"></a>测试文档编写与缺陷管理</h2><p>测试文档包括：测试计划文档，测试设计规格文档，测试用例，软件缺陷报告，状态报告。</p>
<p>测试用例对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。测试用例一般包括验证测试用例和证伪测试用例；验证测试用例用于验证代码是否按照预期执行，得到预期结果；证伪测试用例验证代码是否对异常和错误条件进行了适当处理。</p>
<p>缺陷报告包括：问题/错误的简单描述，重现的环境配置要求，保证多次精确重复的特定输入，期望结果与实际结果的对比，优先级与严重性，对客户的影响等。</p>
<h2 id="常用的测试工具"><a href="#常用的测试工具" class="headerlink" title="常用的测试工具"></a>常用的测试工具</h2><h3 id="功能测试UFT"><a href="#功能测试UFT" class="headerlink" title="功能测试UFT"></a>功能测试UFT</h3><h4 id="UFT自动化测试的原理"><a href="#UFT自动化测试的原理" class="headerlink" title="UFT自动化测试的原理"></a>UFT自动化测试的原理</h4><ul>
<li>封装真实被测对象并转化为UFT对象到对象库。</li>
<li>对比对象库里的对象鉴别属性和运行时的真实被测对象的鉴别属性。</li>
<li>对比结果一致，则说明对象成功匹配并可以继续对该真实被测对象进行后续操作；如果不一致则报错，提示对象无法识别。</li>
</ul>
<h3 id="封装对象模型"><a href="#封装对象模型" class="headerlink" title="封装对象模型"></a>封装对象模型</h3><p>在UFT里的封装对象共分两个概念，Test Objects（测试对象，TO）和Runtime Objects（运行时对象，RO）。TO就是被被添加到对象库中的对象，RO就是被测试软件在运行实际所运行的对象。他们都是UFT封装的对象，TO是为了识别RO而存在的。</p>
<p>UFT识别对象通常先在对象库中添加测试对象，然后在被测软件运行的时候，根据脚本中调用的对象名称，在对象库中找到相应的测试对象，并根据这些对象的特征属性，在被测试软件中搜索相匹配的正在运行的对象，最后就可以对这些实际运行的测试对象进行操作。</p>
<p>GetTOProperty()<br>    基本含义：获取对象库中某个对象的某个属性的值。<br>    公式：ReturnValue = 对象.GetTOProperty(“封装属性名”)</p>
<pre><code>SetTOProperty()
基本含义：设置对象库中某个对象的某个属性的值。
公式：对象.SetTOProperty &quot;封装属性名&quot; &quot;封装属性值&quot;
注：使用代码形式的修改对象属性属于临时性的，只在脚本运行时有效，一旦脚本运行结束，对象库里的属性值就会还原。

GetROProperty()
基本含义：获取实际运行时的某个对象的某个属性的值。
公式：ReturnValue = 对象.GetROProperty(&quot;封装属性名&quot;)
注：使用GetROProperty这个方法来动态获取实际运行时的一些确认信息，然后和所预期的测试数据做对比。如注册功能，在提交一些注册信息以后，一般都要到接下来的确认页面去验证一些信息，这就可以使用GetROProperty来动态获取实际运行时的一些确认信息。
</code></pre><h4 id="对象无法识别的解决办法"><a href="#对象无法识别的解决办法" class="headerlink" title="对象无法识别的解决办法"></a>对象无法识别的解决办法</h4><pre><code>设置虚拟对象。不推荐，虚拟对象非常脆弱，难以维护；即使对象没有发生变化，但只要对象在界面是那个的方位发生变化，虚拟对象就会识别失败。
使用相对坐标配合WSH去定位对象。
使用DOM组建接口应用技术。只适用于Web项目。
使用UFT自定义扩展SDK Customer来进行二次开发使UFT能够识别对象。难度大。
开发提供专属插件。
把无法识别的对象的一些方法封装到一个dll中并使用UFT调用。
</code></pre><h4 id="数据驱动与场景恢复"><a href="#数据驱动与场景恢复" class="headerlink" title="数据驱动与场景恢复"></a>数据驱动与场景恢复</h4><pre><code>数据驱动Data Table的应用：实现测试数据和脚本业务的分离。
场景恢复：场景恢复可以应对多种类型的错误并进行恢复操作。
</code></pre><h3 id="性能测试LoadRunner"><a href="#性能测试LoadRunner" class="headerlink" title="性能测试LoadRunner"></a>性能测试LoadRunner</h3><ul>
<li>LoadRunner是一种适用于各种体系架构的自动负载测试工具，它能预测系统行为并优化系统性能。LoadRunner的测试对象是整个企业的系统，它通过模拟实际用户的操作行为和实时性能监测，来帮助测试人员更快地查找和发现问题。<br>*</li>
<li>轻松创建虚拟用户。Virtual User Generator能够生成虚拟用于，以虚拟用户的方式模拟真实用户的业务操作行为。它先记录下业务流程，然后将其转化为测试脚本，并进行参数化操作（Data Wizard直接连接数据服务器获取数据）。利用虚拟用户可以在不同操作系统上同时产生成千上万用户访问，能极大的减少负载测试所需要的硬件和人力资源。</li>
<li>创建真实负载。建立虚拟用户后，需要设定负载方案、业务流程组合和虚拟用户数量。用Controller能够很快地组织多用户测试方案。</li>
<li>定位性能问题。LoadRunner内含一个实时检测器，在负载测试过程的任何时候都能观察到应用系统的运行性能。</li>
<li>分析结果。一旦测试完毕，LoadRunner收集汇总所有的测试数据，并提供高级的分析和报告工具，一遍迅速找到性能问题并做出相应的调整。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/03/05/APP-Test-005/" data-id="cjl99ljw50004nsjynns9wvqt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-004" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/25/APP-Test-004/" class="article-date">
  <time datetime="2017-02-25T09:23:55.000Z" itemprop="datePublished">2017-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/25/APP-Test-004/">APP测试总结（四）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h2 id="自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。"><a href="#自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。" class="headerlink" title="自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。"></a>自动化测试：以程序测试程序、以代码代替思维、以脚本运行代替手工测试。</h2><ul>
<li><p>冒烟测试:就是在一个新版本出来的时候，将软件的全部功能过一遍，看有没有什么大问题。如果功能可以正常运行，不会影响测试进行，那么这个版本就可以真正开始测试了。如果功能有重大问题或影响测试进行，那么这个版本就是不合格的，不用进行进一步的测试。比如，拿到QQ的app新版本，登陆都登陆不上，那么这个版本肯定无法继续测下去。或者，游戏中新的模块出现，但是新的模块总是崩溃、卡死，测试进行不下去，那么冒烟的结果就是不合格的。</p>
</li>
<li><p>回归测试:就是以前版本中发现的bug在新的版本中验证是否存在且是否引发新的bug。</p>
</li>
</ul>
<h2 id="自动化测试的优势"><a href="#自动化测试的优势" class="headerlink" title="自动化测试的优势"></a>自动化测试的优势</h2><ul>
<li>回归测试更方便、可靠。由于回归测试的业务流程操作和测试用例是预先设计好的，预期结果也是完全在项目人员掌握之中的，将回归测试交给计算机自动运行，可以极大提高测试效率，缩短回归测试时间。</li>
<li>可运行更多更繁琐的测试，且快速高效。</li>
<li>可执行一些对于手工测试来说相当困难或根本做不到的测试。比如，对大量用户的并发测试等。</li>
<li>具有一致性和可重复性的特点。</li>
<li>自动化测试脚本完全具有复用性。由于自动化测试通常以脚本的方式实现，这样在不同的版本之间，就可能只需要做少量的维护甚至不做任何修改，实现在不同的测试版本中使用相同的测试脚本执行相同的测试用例。</li>
</ul>
<h2 id="自动化测试的劣势"><a href="#自动化测试的劣势" class="headerlink" title="自动化测试的劣势"></a>自动化测试的劣势</h2><ul>
<li>永远不可能完全取代手工测试。自动化测试无法做到手工测试的覆盖率，不是每个测试用例都适合转换成自动化测试用例的。</li>
<li>无法保证测试的正确性。测试脚本本身也可能存在缺陷。</li>
<li>手工测试能发现的缺陷远比自动化测试多。自动化测试几乎是无法发现新缺陷。</li>
<li>自动化测试工具是死的，它本身没有任何想象力。</li>
<li>自动化测试对测试工程师来说必须有一定的开发技术背景。</li>
</ul>
<h2 id="引入自动化测试的时机"><a href="#引入自动化测试的时机" class="headerlink" title="引入自动化测试的时机"></a>引入自动化测试的时机</h2><p>项目周期长，系统版本不断。主要在于回归测试。<br>需求变更不频繁。<br>系统中的测试对象基本可以正常识别，不存在大批量第三方控件。<br>需要反复测试，如可靠性测试需要进行上千次的系统测试。</p>
<h2 id="何时避免展开自动化测试"><a href="#何时避免展开自动化测试" class="headerlink" title="何时避免展开自动化测试"></a>何时避免展开自动化测试</h2><p>项目周期短，需求变更频繁。项目周期短的情况下引入自动化测试，不但收不回成本，而且会延长产品的发布时间。需求频繁改变会使老功能的业务逻辑被修改，从而导致相应的测试脚本也需相应修改。<br>软件版本还没稳定。<br>多数对象无法识别以及脚本维护频繁与艰难。</p>
<h2 id="自动化测试用例设计"><a href="#自动化测试用例设计" class="headerlink" title="自动化测试用例设计"></a>自动化测试用例设计</h2><p>在项目的测试过程中，测试工程师都会首先分析测试需求，产出测试计划后，编写和设计测试用例，设计开发测试脚本。</p>
<ul>
<li>自动化测试用例的范围往往是核心业务流程或者重复执行率较高的。并不需要覆盖所有的手工测试用例。</li>
<li>自动化测试用例的选择一般以“正向”为主。正常情况即为“正向”，异常情况即为“反向”。功能自动化测试主要还是用于回归测试，回归测试的目的就是保证新增功能后老功能是否能够正常运作。</li>
<li>手工测试用例可以不用回归原点，而自动化用例往往是必须的。所谓回归原点就是执行的测试用例最终需要恢复其在执行前的初始状态。比如添加用户功能，由于用户名是唯一的，第一次执行时没有问题，第二次执行时程序就会出现用户名重复而报错；这种情况下，就需要在自动化测试用例最后增加删除该用户的步骤。</li>
<li>自动化测试用例与手工测试用例不同，不需要每个步骤都写预期结果。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/02/25/APP-Test-004/" data-id="cjl99ljw30003nsjy7s5st1s6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-003" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/21/APP-Test-003/" class="article-date">
  <time datetime="2017-02-21T09:23:55.000Z" itemprop="datePublished">2017-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/APP-Test-003/">APP测试总结（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="软件测试类型"><a href="#软件测试类型" class="headerlink" title="软件测试类型"></a>软件测试类型</h2><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试并不是对整个程序进行测试，而是对构成程序的较小模块进行测试。单元测试减小了调试的难度（一旦某个错误被发现出来，我们就知道它在哪个具体的模块中）；单元测试提供了同时测试多个模块的可能，将并行工程引入软件测试中。</p>
<p>在为模块单元测试设计测试用例时，需要使用两种类型的信息：模块的规格说明和模块的源代码。规格说明一般都规定了模块的输入和输出参数以及模块的功能。单元测试总体上是面向白盒测试的，因此，单元测试的测试用例的设计过程如下：使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>自顶向下集成和自底向上集成</p>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>功能测试的目的是为了暴露程序的错误以及与规格说明不一致之处，而不是为了证明程序符合其外部规格说明。</p>
<p>功能测试是一种黑盒测试，功能测试常用步骤有：根据需求来细分功能点，根据功能点派生测试需求，根据测试需求设计功能测试用例。</p>
<h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>系统测试的目的是为了证明程序不能实现其目标，系统测试的测试用例设计有以下14种类型：</p>
<ul>
<li>能力测试：是判断目标文档提及的每一项能力（或功能）是否都确实已经实现。</li>
<li>容量测试：使程序经受大容量数据的检验。容量测试的目的是为了证明程序不能处理目标文档中规定的数据容量。</li>
<li>强度测试：使程序承受高负载或强度的检验。所谓高强度是指在很短的时间间隔内达到的数据或操作的数量峰值。</li>
<li>易用性测试：试图发现人为因素或易用性的问题。</li>
<li>安全性测试：设计测试用例来突破程序安全检查的过程。举例来说，我们可以设计测试用例来规避操作系统的内存保护机制，破坏数据库管理系统的数据安全机制。</li>
<li>性能测试：很多软件都有特定的性能或效率目标，这终特性描述为在特定负载和配置环境下程序的响应时间和吞吐率。</li>
<li>存储测试：</li>
<li>配置测试：</li>
<li>兼容性测试。</li>
<li>安装测试：有些类型的软件系统安装过程非常复杂，测试安装过程是系统测试中的一个重要部分。对于包含在软件包中的自动安装系统而言，这尤其重要。安装程序如果出现故障，会影响用户对软件的成功体验。</li>
<li>可靠性测试：所有类型的测试都是为了提高软件的可靠性，但是如果软件的目标中包含了对可靠性的特别描述，就必须设计专门的可靠性测试。</li>
<li>可恢复性测试：诸如操作系统、数据库管理系统和远程处理系统等软件通常都有可恢复性目标，说明系统如何从程序错误、硬件失效和数据错误中恢复过来。系统测试的一个目标是证明这些恢复机制不能够正确发挥作用。我们可以故意将程序错误置入某个系统中，判断系统是否可以从中恢复。</li>
<li>适用性测试</li>
<li>文档测试：检查用户文档的正确性。用户文档应成为审查的对象，检查其正确性和清晰性。在文档中描述的任何范例应编成测试用例，并提交给程序。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/02/21/APP-Test-003/" data-id="cjl99ljw80005nsjyfb1t15b0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APP-Test-002" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/19/APP-Test-002/" class="article-date">
  <time datetime="2017-02-19T09:23:55.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/APP-Test-002/">APP测试总结（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><p>测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果。测试用例是执行的最小实体。简单地说，测试用例就是设计一个场景，使软件程序在这种场景下，必须能够正常运行并且达到程序所设计的执行结果。</p>
<p>##1.1 黑盒测试与白盒测试</p>
<p>黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。白盒测试：已知产品的内部工作过程，可以进行测试证明每种内部操作是否符合设计规格要求，所有内部成分是否经过检查。</p>
<p>合理的测试策略是将这两种测试要素组合起来。我们可以通过使用特定的面向黑盒测试的测试用例设计方法，而后使用白盒测试方法对程序的逻辑结构进行检查以补充这些测试用例，借此来设计出一个相当严格的测试。</p>
<p>白盒测试方法有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖。黑盒测试方法有等价类划分、边界值分析、因果图分析、错误测试、状态图、场景法等。</p>
<h2 id="1-2-白盒测试用例设计"><a href="#1-2-白盒测试用例设计" class="headerlink" title="1.2 白盒测试用例设计"></a>1.2 白盒测试用例设计</h2><p>白盒测试关注的是测试用例执行的程度或覆盖程序逻辑结构（源代码）的程度。完全的白盒测试是将程序中每条路径都执行到，然而对一个带有循环的程序来说，完全的路径测试并不切合实际。白盒测试的特点：依据软件设计说明书进行测试、对程序内部细节的严密检验、针对特定条件设计测试用例、对软件的逻辑路径进行覆盖测试。</p>
<p>语句覆盖是最起码的结构覆盖要求，语句覆盖要求设计足够多的测试用例，使得程序中每条语句至少被执行一次。可以很直观地从源代码得到测试用例，无须细分每条判定表达式。由于这种测试方法仅仅针对程序逻辑中显式存在的语句，但对于隐藏的条件和可能到达的隐式逻辑分支，是无法测试的。（遗漏隐藏的逻辑分支）</p>
<p>判定覆盖要求必须编写足够的测试用例，使得每一个判断都至少有一个为“真”和为“假”的输出结果。判定覆盖比语句覆盖要多几乎一倍的测试路径，当然也就具有比语句覆盖更强的测试能力。同样判定覆盖也具有和语句覆盖一样的简单性，无须细分每个判定就可以得到测试用例。往往大部分的判定语句是由多个逻辑条件组合而成（如，判定语句中包含AND、OR、CASE），若仅仅判断其整个最终结果，而忽略每个条件的取值情况，必然会遗漏部分测试路径。（遗漏组合判定中的某些条件取值）</p>
<p>条件覆盖要求设计足够多的测试用例，使得判定中的每个条件获得各种可能的结果，即每个条件至少有一次为真值，有一次为假值。要达到条件覆盖，需要足够多的测试用例，但条件覆盖并不能保证判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果。</p>
<p>判定/条件覆盖要求设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。判定/条件覆盖满足判定覆盖准则和条件覆盖准则，弥补了二者的不足。判定/条件覆盖准则的缺点是未考虑条件的组合情况。</p>
<p>多重条件覆盖要求设计足够多的测试用例，使得每个判定中条件结果的所有可能组合至少出现一次。多重条件覆盖准则满足判定覆盖、条件覆盖和判定/条件覆盖准则。更改的判定/条件覆盖要求设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身的所有可能结果也至少出现一次。并且每个条件都显示能单独影响判定结果。缺点是线性地增加了测试用例的数量。</p>
<p>路径覆盖要求设计足够的测试用例，覆盖程序中所有可能的路径。由于路径覆盖需要对所有可能的路径进行测试（包括循环、条件组合、分支选择等），那么需要设计大量、复杂的测试用例，使得工作量呈指数级增长。而在有些情况下，一些执行路径是不可能被执行的，这样不仅降低了测试效率，而且大量的测试结果的累积，也为排错带来麻烦。</p>
<h2 id="1-3-黑盒测试用例设计"><a href="#1-3-黑盒测试用例设计" class="headerlink" title="1.3 黑盒测试用例设计"></a>1.3 黑盒测试用例设计</h2><h3 id="1-3-1-等价类划分"><a href="#1-3-1-等价类划分" class="headerlink" title="1.3.1 等价类划分"></a>1.3.1 等价类划分</h3><p>等价类划分是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。等价类分为有效等价类和无效等价类，其中，有效等价类是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合；而无效等价类是指对于程序的规格说明来说是不合理的，没有意义的输入数据构成的集合。设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。划分等价类有以下原则：</p>
<ul>
<li>在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0～100；则小于0和大于100的为无效等价类，0~100之间的为有效等价类。</li>
<li>在输入条件规定了输入值的集合或者规定了”必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类。</li>
<li>在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类。</li>
<li>在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类。例：输入条件说明学历可为:专科、本科、硕士、博士四种之一，则分别取这四种这四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。</li>
<li>在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；</li>
<li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。</li>
<li>在确立了等价类后,可建立等价类表,列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：</li>
</ul>
<p>为每一个等价类规定一个唯一的编号；</p>
<ul>
<li>设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；</li>
<li>设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止。</li>
</ul>
<h3 id="1-3-2-边界值分析"><a href="#1-3-2-边界值分析" class="headerlink" title="1.3.2 边界值分析"></a>1.3.2 边界值分析</h3><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。</p>
<p>长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。</p>
<h3 id="1-3-3-因果图"><a href="#1-3-3-因果图" class="headerlink" title="1.3.3 因果图"></a>1.3.3 因果图</h3><p>因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p>
<p>等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。</p>
<h3 id="1-3-4-错误测试"><a href="#1-3-4-错误测试" class="headerlink" title="1.3.4 错误测试"></a>1.3.4 错误测试</h3><p>错误测试是基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。</p>
<p>如测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：</p>
<ul>
<li>输入的线性表为空表；</li>
<li>表中只含有一个元素；</li>
<li>输入表中所有元素已排好序；</li>
<li>输入表已按逆序排好；</li>
<li>输入表中部分或全部元素相同。</li>
</ul>
<h2 id="1-4-测试用例设计综合策略"><a href="#1-4-测试用例设计综合策略" class="headerlink" title="1.4 测试用例设计综合策略"></a>1.4 测试用例设计综合策略</h2><p>Myers提出了使用各种测试方法的综合策略：</p>
<ul>
<li>在任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强。</li>
<li>必要时用等价类划分方法补充一些测试用例。</li>
<li>用错误推测法再追加一些测试用例。</li>
<li>对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，应当再补充足够的测试用例。</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法。</li>
</ul>
<p>测试用例的设计步骤：1)构造根据设计规格得出的基本功能测试用例；2)边界值测试用例；3)状态转换测试用例；4)错误猜测测试用例；5)异常测试用例；6)性能测试用例；7)压力测试用例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://softwaretest.cn/2017/02/19/APP-Test-002/" data-id="cjl99ljvv0000nsjyemelbqyn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APP测试/">APP测试</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APP测试/">APP测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Charles/">Charles</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matlab/">Matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quality-Assurance/">Quality Assurance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIM/">VIM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/接口测试/">接口测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/APP测试/" style="font-size: 20px;">APP测试</a> <a href="/tags/Charles/" style="font-size: 12px;">Charles</a> <a href="/tags/Data-Structure/" style="font-size: 10px;">Data Structure</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Linux/" style="font-size: 16px;">Linux</a> <a href="/tags/Matlab/" style="font-size: 10px;">Matlab</a> <a href="/tags/Python/" style="font-size: 18px;">Python</a> <a href="/tags/Quality-Assurance/" style="font-size: 10px;">Quality Assurance</a> <a href="/tags/Shell/" style="font-size: 14px;">Shell</a> <a href="/tags/VIM/" style="font-size: 14px;">VIM</a> <a href="/tags/git/" style="font-size: 16px;">git</a> <a href="/tags/接口测试/" style="font-size: 10px;">接口测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/25/git-002/">git-基本操作（二）</a>
          </li>
        
          <li>
            <a href="/2018/08/24/git-001/">git-基本操作（一）</a>
          </li>
        
          <li>
            <a href="/2018/08/23/Charles-001/">Charles 重定向功能——Map Local</a>
          </li>
        
          <li>
            <a href="/2018/08/22/Charles-002/">Charles——模拟慢速网络</a>
          </li>
        
          <li>
            <a href="/2018/08/21/QA的职责/">QA的职责</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 hannie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>